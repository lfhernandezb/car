dsoft/java/SQLiteORM/scripts/../lib/sqlite-jdbc4-3.8.2-SNAPSHOT.jar:dsoft/java/SQLiteORM/scripts/../lib/sqlite-jdbc-3.7.15-SNAPSHOT.jar:dsoft/java/SQLiteORM/scripts/../lib/mysql-connector-java-5.1.22-bin.jar:dsoft/java/SQLiteORM/scripts/../lib/log4j-1.2.17.jar:dsoft/java/SQLiteORM/scripts/../lib/ini4j-0.5.2-SNAPSHOT.jar:dsoft/java/SQLiteORM/scripts/../bin/SQLiteORM.jar
log4j: Using URL [file:dsoft/java/SQLiteORM/scripts/../etc/log4j.xml] for automatic log4j configuration.
log4j: Preferred configurator class: org.apache.log4j.xml.DOMConfigurator
log4j: System property is :null
log4j: Standard DocumentBuilderFactory search succeded.
log4j: DocumentBuilderFactory is: com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl
log4j: debug attribute= "null".
log4j: Ignoring debug attribute.
log4j: reset attribute= "false".
log4j: Threshold ="null".
log4j: Level value for root is  [trace].
log4j: root level set to TRACE
log4j: Class name: [org.apache.log4j.ConsoleAppender]
log4j: Parsing layout of class: "org.apache.log4j.PatternLayout"
log4j: Setting property [conversionPattern] to [%5p [%t] (%F:%L) - %m%n].
log4j: Adding appender named [stdout] to category [root].
log4j: Class name: [org.apache.log4j.RollingFileAppender]
log4j: Setting property [file] to [/var/log/myorm.log].
log4j: Setting property [maxFileSize] to [100KB].
log4j: Setting property [maxBackupIndex] to [1].
log4j: Parsing layout of class: "org.apache.log4j.PatternLayout"
log4j: Setting property [conversionPattern] to [%d{yyyy-MM-dd HH:mm:ss} [%t] %-5p %c{1}:%L - %m%n].
log4j: setFile called: /var/log/myorm.log, true
log4j: setFile ended
log4j: Adding appender named [R] to category [root].
DEBUG [main] (SQLiteORM.java:82) - conn: org.sqlite.SQLiteConnection@8e32e7
DEBUG [main] (SQLiteORM.java:139) - table: autenticacion
DEBUG [main] (SQLiteORM.java:150) - columns:
/**
 * 
 */
package bd;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.AbstractMap;
import java.util.ArrayList;

/**
 * @author petete-ntbk
 *
 */
public class Autenticacion {
private String _fecha;
private Integer _id_red_social;
private String _token;
private Integer _id_usuario;
private Integer _id;

    private final static String _str_sql = 
        "    SELECT" +
        "    au.fecha AS fecha," +
        "    au.id_red_social AS id_red_social," +
        "    au.token AS token," +
        "    au.id_usuario AS id_usuario," +
        "    au.id_autenticacion AS id" +
        "    FROM autenticacion au";

    public Autenticacion() {
        _fecha = null;
        _id_red_social = null;
        _token = null;
        _id_usuario = null;
        _id = null;

    }
    /**
     * @return the _fecha
     */
    public String get_fecha() {
        return _fecha;
    }
    /**
     * @return the _id_red_social
     */
    public Integer get_id_red_social() {
        return _id_red_social;
    }
    /**
     * @return the _token
     */
    public String get_token() {
        return _token;
    }
    /**
     * @return the _id_usuario
     */
    public Integer get_id_usuario() {
        return _id_usuario;
    }
    /**
     * @return the _id
     */
    public Integer get_id() {
        return _id;
    }
    /**
     * @param _fecha the _fecha to set
     */
    public void set_fecha(String _fecha) {
        this._fecha = _fecha;
    }
    /**
     * @param _id_red_social the _id_red_social to set
     */
    public void set_id_red_social(Integer _id_red_social) {
        this._id_red_social = _id_red_social;
    }
    /**
     * @param _token the _token to set
     */
    public void set_token(String _token) {
        this._token = _token;
    }
    /**
     * @param _id_usuario the _id_usuario to set
     */
    public void set_id_usuario(Integer _id_usuario) {
        this._id_usuario = _id_usuario;
    }
    /**
     * @param _id the _id to set
     */
    public void set_id(Integer _id) {
        this._id = _id;
    }

    public static Autenticacion fromRS(ResultSet p_rs) throws SQLException {
        Autenticacion ret = new Autenticacion();

        ret.set_fecha(p_rs.getString("fecha"));
        ret.set_id_red_social(p_rs.getInt("id_red_social"));
        ret.set_token(p_rs.getString("token"));
        ret.set_id_usuario(p_rs.getInt("id_usuario"));
        ret.set_id(p_rs.getInt("id"));

        return ret;
    }

    public static Autenticacion getByParameter(Connection p_conn, String p_key, String p_value) throws SQLException {
        Autenticacion ret = null;
        
        String str_sql = _str_sql +
            "  WHERE au." + p_key + " = " + p_value +
            "  LIMIT 0, 1";
        
        //System.out.println(str_sql);
        
        // assume that conn is an already created JDBC connection (see previous examples)
        Statement stmt = null;
        ResultSet rs = null;
        
        try {
            stmt = p_conn.createStatement();
            //System.out.println("stmt = p_conn.createStatement() ok");
            rs = stmt.executeQuery(str_sql);
            //System.out.println("rs = stmt.executeQuery(str_sql) ok");

            // Now do something with the ResultSet ....
            
            if (rs.next()) {
                //System.out.println("rs.next() ok");
                ret = fromRS(rs);
                //System.out.println("fromRS(rs) ok");
            }
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        
        
        return ret;        
    }

    public static Autenticacion getById(Connection p_conn, String p_id) throws Exception {
        return getByParameter(p_conn, "id_autenticacion", p_id);
    }
    
    public static ArrayList<Autenticacion> seek(Connection p_conn, ArrayList<AbstractMap.SimpleEntry<String, String>> p_parameters, String p_order, String p_direction, int p_offset, int p_limit) throws Exception {
        Statement stmt = null;
        ResultSet rs = null;
        String str_sql;
        ArrayList<Autenticacion> ret;
        
        str_sql = "";
        
        try {
            ArrayList<String> array_clauses = new ArrayList<String>();
            
            ret = new ArrayList<Autenticacion>();
            
            str_sql = _str_sql;
            
            for (AbstractMap.SimpleEntry<String, String> p : p_parameters) {
                if (p.getKey().equals("id_autenticacion")) {
                    array_clauses.add("au.id_autenticacion = " + p.getValue());
                }
                else if (p.getKey().equals("id_red_social")) {
                    array_clauses.add("au.id_red_social = " + p.getValue());
                }
                else if (p.getKey().equals("id_usuario")) {
                    array_clauses.add("au.id_usuario = " + p.getValue());
                }
                else {
                    throw new Exception("Parametro no soportado: " + p.getKey());
                }
            }
                                
            boolean bFirstTime = false;
            
            for(String clause : array_clauses) {
                if (!bFirstTime) {
                     bFirstTime = true;
                     str_sql += " WHERE ";
                }
                else {
                     str_sql += " AND ";
                }
                str_sql += clause;
            }
            
            if (p_order != null && p_direction != null) {
                str_sql += " ORDER BY " + p_order + " " + p_direction;
            }
            
            if (p_offset != -1 && p_limit != -1) {
                str_sql += "  LIMIT " +  Integer.toString(p_offset) + ", " + Integer.toString(p_limit);
            }
            
            //echo "<br>" . str_sql . "<br>";
        
            stmt = p_conn.createStatement();
            
            rs = stmt.executeQuery(str_sql);
            
            while (rs.next()) {
                ret.add(fromRS(rs));
            }
            /*
            if (ret.size() == 0) {
                ret = null;
            }
            */
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        catch (Exception ex) {
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        

        return ret;
    }

    public int update(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    UPDATE autenticacion" +
            "    SET" +
            "    fecha = " + (_fecha != null ? "'" + _fecha + "'" : "null") + "," +
            "    token = " + (_token != null ? "'" + _token + "'" : "null") +
            "    WHERE" +
            "    id_autenticacion = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
            /*
            if (stmt.executeUpdate(str_sql) < 1) {
                throw new Exception("No hubo filas afectadas");
            }
            */
            
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
    
    public int insert(Connection p_conn) throws SQLException {
        
        int ret = -1;
        Statement stmt = null;
        ResultSet rs = null;

        String str_sql =
            "    INSERT INTO autenticacion" +
            "    (" +
            "    fecha, " +
            "    id_red_social, " +
            "    token, " +
            "    id_usuario, " +
            "    id_autenticacion)" +
            "    VALUES" +
            "    (" +
            "    " + (_fecha != null ? "'" + _fecha + "'" : "null") + "," +
            "    " + (_id_red_social != null ? "'" + _id_red_social + "'" : "null") + "," +
            "    " + (_token != null ? "'" + _token + "'" : "null") + "," +
            "    " + (_id_usuario != null ? "'" + _id_usuario + "'" : "null") + "," +
            "    " + (_id_autenticacion != null ? "'" + _id_autenticacion + "'" : "null") +
            "    )";
        
        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);

        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }

    public int delete(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    DELETE FROM autenticacion" +
            "    WHERE" +
            "    id_autenticacion = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
}

DEBUG [main] (SQLiteORM.java:139) - table: combustible
DEBUG [main] (SQLiteORM.java:150) - columns:
/**
 * 
 */
package bd;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.AbstractMap;
import java.util.ArrayList;

/**
 * @author petete-ntbk
 *
 */
public class Combustible {
private String _fecha_modificacion;
private String _descripcion;
private Integer _id;

    private final static String _str_sql = 
        "    SELECT" +
        "    co.fecha_modificacion AS fecha_modificacion," +
        "    co.descripcion AS descripcion," +
        "    co.id_combustible AS id" +
        "    FROM combustible co";

    public Combustible() {
        _fecha_modificacion = null;
        _descripcion = null;
        _id = null;

    }
    /**
     * @return the _fecha_modificacion
     */
    public String get_fecha_modificacion() {
        return _fecha_modificacion;
    }
    /**
     * @return the _descripcion
     */
    public String get_descripcion() {
        return _descripcion;
    }
    /**
     * @return the _id
     */
    public Integer get_id() {
        return _id;
    }
    /**
     * @param _fecha_modificacion the _fecha_modificacion to set
     */
    public void set_fecha_modificacion(String _fecha_modificacion) {
        this._fecha_modificacion = _fecha_modificacion;
    }
    /**
     * @param _descripcion the _descripcion to set
     */
    public void set_descripcion(String _descripcion) {
        this._descripcion = _descripcion;
    }
    /**
     * @param _id the _id to set
     */
    public void set_id(Integer _id) {
        this._id = _id;
    }

    public static Combustible fromRS(ResultSet p_rs) throws SQLException {
        Combustible ret = new Combustible();

        ret.set_fecha_modificacion(p_rs.getString("fecha_modificacion"));
        ret.set_descripcion(p_rs.getString("descripcion"));
        ret.set_id(p_rs.getInt("id"));

        return ret;
    }

    public static Combustible getByParameter(Connection p_conn, String p_key, String p_value) throws SQLException {
        Combustible ret = null;
        
        String str_sql = _str_sql +
            "  WHERE co." + p_key + " = " + p_value +
            "  LIMIT 0, 1";
        
        //System.out.println(str_sql);
        
        // assume that conn is an already created JDBC connection (see previous examples)
        Statement stmt = null;
        ResultSet rs = null;
        
        try {
            stmt = p_conn.createStatement();
            //System.out.println("stmt = p_conn.createStatement() ok");
            rs = stmt.executeQuery(str_sql);
            //System.out.println("rs = stmt.executeQuery(str_sql) ok");

            // Now do something with the ResultSet ....
            
            if (rs.next()) {
                //System.out.println("rs.next() ok");
                ret = fromRS(rs);
                //System.out.println("fromRS(rs) ok");
            }
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        
        
        return ret;        
    }

    public static Combustible getById(Connection p_conn, String p_id) throws Exception {
        return getByParameter(p_conn, "id_combustible", p_id);
    }
    
    public static ArrayList<Combustible> seek(Connection p_conn, ArrayList<AbstractMap.SimpleEntry<String, String>> p_parameters, String p_order, String p_direction, int p_offset, int p_limit) throws Exception {
        Statement stmt = null;
        ResultSet rs = null;
        String str_sql;
        ArrayList<Combustible> ret;
        
        str_sql = "";
        
        try {
            ArrayList<String> array_clauses = new ArrayList<String>();
            
            ret = new ArrayList<Combustible>();
            
            str_sql = _str_sql;
            
            for (AbstractMap.SimpleEntry<String, String> p : p_parameters) {
                if (p.getKey().equals("id_combustible")) {
                    array_clauses.add("co.id_combustible = " + p.getValue());
                }
                else if (p.getKey().equals("mas reciente")) {
                    array_clauses.add("co.fecha_modificacion > STR_TO_DATE('" + p.getValue() + "', '%d-%m-%Y %H:%i:%s')");
                }
                else {
                    throw new Exception("Parametro no soportado: " + p.getKey());
                }
            }
                                
            boolean bFirstTime = false;
            
            for(String clause : array_clauses) {
                if (!bFirstTime) {
                     bFirstTime = true;
                     str_sql += " WHERE ";
                }
                else {
                     str_sql += " AND ";
                }
                str_sql += clause;
            }
            
            if (p_order != null && p_direction != null) {
                str_sql += " ORDER BY " + p_order + " " + p_direction;
            }
            
            if (p_offset != -1 && p_limit != -1) {
                str_sql += "  LIMIT " +  Integer.toString(p_offset) + ", " + Integer.toString(p_limit);
            }
            
            //echo "<br>" . str_sql . "<br>";
        
            stmt = p_conn.createStatement();
            
            rs = stmt.executeQuery(str_sql);
            
            while (rs.next()) {
                ret.add(fromRS(rs));
            }
            /*
            if (ret.size() == 0) {
                ret = null;
            }
            */
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        catch (Exception ex) {
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        

        return ret;
    }

    public int update(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    UPDATE combustible" +
            "    SET" +
            "    fecha_modificacion = " + (_fecha_modificacion != null ? "'" + _fecha_modificacion + "'" : "null") + "," +
            "    descripcion = " + (_descripcion != null ? "'" + _descripcion + "'" : "null") +
            "    WHERE" +
            "    id_combustible = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
            /*
            if (stmt.executeUpdate(str_sql) < 1) {
                throw new Exception("No hubo filas afectadas");
            }
            */
            
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
    
    public int insert(Connection p_conn) throws SQLException {
        
        int ret = -1;
        Statement stmt = null;
        ResultSet rs = null;

        String str_sql =
            "    INSERT INTO combustible" +
            "    (" +
            "    descripcion, " +
            "    id_combustible)" +
            "    VALUES" +
            "    (" +
            "    " + (_descripcion != null ? "'" + _descripcion + "'" : "null") + "," +
            "    " + (_id_combustible != null ? "'" + _id_combustible + "'" : "null") +
            "    )";
        
        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);

        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }

    public int delete(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    DELETE FROM combustible" +
            "    WHERE" +
            "    id_combustible = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
}

DEBUG [main] (SQLiteORM.java:139) - table: comuna
DEBUG [main] (SQLiteORM.java:150) - columns:
/**
 * 
 */
package bd;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.AbstractMap;
import java.util.ArrayList;

/**
 * @author petete-ntbk
 *
 */
public class Comuna {
private Integer _id_region;
private String _comuna;
private Integer _id;

    private final static String _str_sql = 
        "    SELECT" +
        "    co.id_region AS id_region," +
        "    co.comuna AS comuna," +
        "    co.id_comuna AS id" +
        "    FROM comuna co";

    public Comuna() {
        _id_region = null;
        _comuna = null;
        _id = null;

    }
    /**
     * @return the _id_region
     */
    public Integer get_id_region() {
        return _id_region;
    }
    /**
     * @return the _comuna
     */
    public String get_comuna() {
        return _comuna;
    }
    /**
     * @return the _id
     */
    public Integer get_id() {
        return _id;
    }
    /**
     * @param _id_region the _id_region to set
     */
    public void set_id_region(Integer _id_region) {
        this._id_region = _id_region;
    }
    /**
     * @param _comuna the _comuna to set
     */
    public void set_comuna(String _comuna) {
        this._comuna = _comuna;
    }
    /**
     * @param _id the _id to set
     */
    public void set_id(Integer _id) {
        this._id = _id;
    }

    public static Comuna fromRS(ResultSet p_rs) throws SQLException {
        Comuna ret = new Comuna();

        ret.set_id_region(p_rs.getInt("id_region"));
        ret.set_comuna(p_rs.getString("comuna"));
        ret.set_id(p_rs.getInt("id"));

        return ret;
    }

    public static Comuna getByParameter(Connection p_conn, String p_key, String p_value) throws SQLException {
        Comuna ret = null;
        
        String str_sql = _str_sql +
            "  WHERE co." + p_key + " = " + p_value +
            "  LIMIT 0, 1";
        
        //System.out.println(str_sql);
        
        // assume that conn is an already created JDBC connection (see previous examples)
        Statement stmt = null;
        ResultSet rs = null;
        
        try {
            stmt = p_conn.createStatement();
            //System.out.println("stmt = p_conn.createStatement() ok");
            rs = stmt.executeQuery(str_sql);
            //System.out.println("rs = stmt.executeQuery(str_sql) ok");

            // Now do something with the ResultSet ....
            
            if (rs.next()) {
                //System.out.println("rs.next() ok");
                ret = fromRS(rs);
                //System.out.println("fromRS(rs) ok");
            }
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        
        
        return ret;        
    }

    public static Comuna getById(Connection p_conn, String p_id) throws Exception {
        return getByParameter(p_conn, "id_comuna", p_id);
    }
    
    public static ArrayList<Comuna> seek(Connection p_conn, ArrayList<AbstractMap.SimpleEntry<String, String>> p_parameters, String p_order, String p_direction, int p_offset, int p_limit) throws Exception {
        Statement stmt = null;
        ResultSet rs = null;
        String str_sql;
        ArrayList<Comuna> ret;
        
        str_sql = "";
        
        try {
            ArrayList<String> array_clauses = new ArrayList<String>();
            
            ret = new ArrayList<Comuna>();
            
            str_sql = _str_sql;
            
            for (AbstractMap.SimpleEntry<String, String> p : p_parameters) {
                if (p.getKey().equals("id_comuna")) {
                    array_clauses.add("co.id_comuna = " + p.getValue());
                }
                else if (p.getKey().equals("id_region")) {
                    array_clauses.add("co.id_region = " + p.getValue());
                }
                else {
                    throw new Exception("Parametro no soportado: " + p.getKey());
                }
            }
                                
            boolean bFirstTime = false;
            
            for(String clause : array_clauses) {
                if (!bFirstTime) {
                     bFirstTime = true;
                     str_sql += " WHERE ";
                }
                else {
                     str_sql += " AND ";
                }
                str_sql += clause;
            }
            
            if (p_order != null && p_direction != null) {
                str_sql += " ORDER BY " + p_order + " " + p_direction;
            }
            
            if (p_offset != -1 && p_limit != -1) {
                str_sql += "  LIMIT " +  Integer.toString(p_offset) + ", " + Integer.toString(p_limit);
            }
            
            //echo "<br>" . str_sql . "<br>";
        
            stmt = p_conn.createStatement();
            
            rs = stmt.executeQuery(str_sql);
            
            while (rs.next()) {
                ret.add(fromRS(rs));
            }
            /*
            if (ret.size() == 0) {
                ret = null;
            }
            */
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        catch (Exception ex) {
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        

        return ret;
    }

    public int update(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    UPDATE comuna" +
            "    SET" +
            "    comuna = " + (_comuna != null ? "'" + _comuna + "'" : "null") +
            "    WHERE" +
            "    id_comuna = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
            /*
            if (stmt.executeUpdate(str_sql) < 1) {
                throw new Exception("No hubo filas afectadas");
            }
            */
            
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
    
    public int insert(Connection p_conn) throws SQLException {
        
        int ret = -1;
        Statement stmt = null;
        ResultSet rs = null;

        String str_sql =
            "    INSERT INTO comuna" +
            "    (" +
            "    id_region, " +
            "    comuna, " +
            "    id_comuna)" +
            "    VALUES" +
            "    (" +
            "    " + (_id_region != null ? "'" + _id_region + "'" : "null") + "," +
            "    " + (_comuna != null ? "'" + _comuna + "'" : "null") + "," +
            "    " + (_id_comuna != null ? "'" + _id_comuna + "'" : "null") +
            "    )";
        
        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);

        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }

    public int delete(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    DELETE FROM comuna" +
            "    WHERE" +
            "    id_comuna = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
}

DEBUG [main] (SQLiteORM.java:139) - table: estilo
DEBUG [main] (SQLiteORM.java:150) - columns:
/**
 * 
 */
package bd;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.AbstractMap;
import java.util.ArrayList;

/**
 * @author petete-ntbk
 *
 */
public class Estilo {
private String _nombre;
private Integer _puertas;
private String _traccion;
private Integer _id_modelo_anio;
private Integer _rendimiento_carretera;
private Integer _rendimiento_ciudad;
private Integer _id;

    private final static String _str_sql = 
        "    SELECT" +
        "    es.nombre AS nombre," +
        "    es.puertas AS puertas," +
        "    es.traccion AS traccion," +
        "    es.id_modelo_anio AS id_modelo_anio," +
        "    es.rendimiento_carretera AS rendimiento_carretera," +
        "    es.rendimiento_ciudad AS rendimiento_ciudad," +
        "    es.id_estilo AS id" +
        "    FROM estilo es";

    public Estilo() {
        _nombre = null;
        _puertas = null;
        _traccion = null;
        _id_modelo_anio = null;
        _rendimiento_carretera = null;
        _rendimiento_ciudad = null;
        _id = null;

    }
    /**
     * @return the _nombre
     */
    public String get_nombre() {
        return _nombre;
    }
    /**
     * @return the _puertas
     */
    public Integer get_puertas() {
        return _puertas;
    }
    /**
     * @return the _traccion
     */
    public String get_traccion() {
        return _traccion;
    }
    /**
     * @return the _id_modelo_anio
     */
    public Integer get_id_modelo_anio() {
        return _id_modelo_anio;
    }
    /**
     * @return the _rendimiento_carretera
     */
    public Integer get_rendimiento_carretera() {
        return _rendimiento_carretera;
    }
    /**
     * @return the _rendimiento_ciudad
     */
    public Integer get_rendimiento_ciudad() {
        return _rendimiento_ciudad;
    }
    /**
     * @return the _id
     */
    public Integer get_id() {
        return _id;
    }
    /**
     * @param _nombre the _nombre to set
     */
    public void set_nombre(String _nombre) {
        this._nombre = _nombre;
    }
    /**
     * @param _puertas the _puertas to set
     */
    public void set_puertas(Integer _puertas) {
        this._puertas = _puertas;
    }
    /**
     * @param _traccion the _traccion to set
     */
    public void set_traccion(String _traccion) {
        this._traccion = _traccion;
    }
    /**
     * @param _id_modelo_anio the _id_modelo_anio to set
     */
    public void set_id_modelo_anio(Integer _id_modelo_anio) {
        this._id_modelo_anio = _id_modelo_anio;
    }
    /**
     * @param _rendimiento_carretera the _rendimiento_carretera to set
     */
    public void set_rendimiento_carretera(Integer _rendimiento_carretera) {
        this._rendimiento_carretera = _rendimiento_carretera;
    }
    /**
     * @param _rendimiento_ciudad the _rendimiento_ciudad to set
     */
    public void set_rendimiento_ciudad(Integer _rendimiento_ciudad) {
        this._rendimiento_ciudad = _rendimiento_ciudad;
    }
    /**
     * @param _id the _id to set
     */
    public void set_id(Integer _id) {
        this._id = _id;
    }

    public static Estilo fromRS(ResultSet p_rs) throws SQLException {
        Estilo ret = new Estilo();

        ret.set_nombre(p_rs.getString("nombre"));
        ret.set_puertas(p_rs.getInt("puertas"));
        ret.set_traccion(p_rs.getString("traccion"));
        ret.set_id_modelo_anio(p_rs.getInt("id_modelo_anio"));
        ret.set_rendimiento_carretera(p_rs.getInt("rendimiento_carretera"));
        ret.set_rendimiento_ciudad(p_rs.getInt("rendimiento_ciudad"));
        ret.set_id(p_rs.getInt("id"));

        return ret;
    }

    public static Estilo getByParameter(Connection p_conn, String p_key, String p_value) throws SQLException {
        Estilo ret = null;
        
        String str_sql = _str_sql +
            "  WHERE es." + p_key + " = " + p_value +
            "  LIMIT 0, 1";
        
        //System.out.println(str_sql);
        
        // assume that conn is an already created JDBC connection (see previous examples)
        Statement stmt = null;
        ResultSet rs = null;
        
        try {
            stmt = p_conn.createStatement();
            //System.out.println("stmt = p_conn.createStatement() ok");
            rs = stmt.executeQuery(str_sql);
            //System.out.println("rs = stmt.executeQuery(str_sql) ok");

            // Now do something with the ResultSet ....
            
            if (rs.next()) {
                //System.out.println("rs.next() ok");
                ret = fromRS(rs);
                //System.out.println("fromRS(rs) ok");
            }
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        
        
        return ret;        
    }

    public static Estilo getById(Connection p_conn, String p_id) throws Exception {
        return getByParameter(p_conn, "id_estilo", p_id);
    }
    
    public static ArrayList<Estilo> seek(Connection p_conn, ArrayList<AbstractMap.SimpleEntry<String, String>> p_parameters, String p_order, String p_direction, int p_offset, int p_limit) throws Exception {
        Statement stmt = null;
        ResultSet rs = null;
        String str_sql;
        ArrayList<Estilo> ret;
        
        str_sql = "";
        
        try {
            ArrayList<String> array_clauses = new ArrayList<String>();
            
            ret = new ArrayList<Estilo>();
            
            str_sql = _str_sql;
            
            for (AbstractMap.SimpleEntry<String, String> p : p_parameters) {
                if (p.getKey().equals("id_estilo")) {
                    array_clauses.add("es.id_estilo = " + p.getValue());
                }
                else if (p.getKey().equals("id_modelo_anio")) {
                    array_clauses.add("es.id_modelo_anio = " + p.getValue());
                }
                else {
                    throw new Exception("Parametro no soportado: " + p.getKey());
                }
            }
                                
            boolean bFirstTime = false;
            
            for(String clause : array_clauses) {
                if (!bFirstTime) {
                     bFirstTime = true;
                     str_sql += " WHERE ";
                }
                else {
                     str_sql += " AND ";
                }
                str_sql += clause;
            }
            
            if (p_order != null && p_direction != null) {
                str_sql += " ORDER BY " + p_order + " " + p_direction;
            }
            
            if (p_offset != -1 && p_limit != -1) {
                str_sql += "  LIMIT " +  Integer.toString(p_offset) + ", " + Integer.toString(p_limit);
            }
            
            //echo "<br>" . str_sql . "<br>";
        
            stmt = p_conn.createStatement();
            
            rs = stmt.executeQuery(str_sql);
            
            while (rs.next()) {
                ret.add(fromRS(rs));
            }
            /*
            if (ret.size() == 0) {
                ret = null;
            }
            */
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        catch (Exception ex) {
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        

        return ret;
    }

    public int update(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    UPDATE estilo" +
            "    SET" +
            "    nombre = " + (_nombre != null ? "'" + _nombre + "'" : "null") + "," +
            "    puertas = " + (_puertas != null ? _puertas : "null") + "," +
            "    traccion = " + (_traccion != null ? "'" + _traccion + "'" : "null") + "," +
            "    rendimiento_carretera = " + (_rendimiento_carretera != null ? _rendimiento_carretera : "null") + "," +
            "    rendimiento_ciudad = " + (_rendimiento_ciudad != null ? _rendimiento_ciudad : "null") +
            "    WHERE" +
            "    id_estilo = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
            /*
            if (stmt.executeUpdate(str_sql) < 1) {
                throw new Exception("No hubo filas afectadas");
            }
            */
            
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
    
    public int insert(Connection p_conn) throws SQLException {
        
        int ret = -1;
        Statement stmt = null;
        ResultSet rs = null;

        String str_sql =
            "    INSERT INTO estilo" +
            "    (" +
            "    nombre, " +
            "    puertas, " +
            "    traccion, " +
            "    id_modelo_anio, " +
            "    rendimiento_carretera, " +
            "    rendimiento_ciudad, " +
            "    id_estilo)" +
            "    VALUES" +
            "    (" +
            "    " + (_nombre != null ? "'" + _nombre + "'" : "null") + "," +
            "    " + (_puertas != null ? "'" + _puertas + "'" : "null") + "," +
            "    " + (_traccion != null ? "'" + _traccion + "'" : "null") + "," +
            "    " + (_id_modelo_anio != null ? "'" + _id_modelo_anio + "'" : "null") + "," +
            "    " + (_rendimiento_carretera != null ? "'" + _rendimiento_carretera + "'" : "null") + "," +
            "    " + (_rendimiento_ciudad != null ? "'" + _rendimiento_ciudad + "'" : "null") + "," +
            "    " + (_id_estilo != null ? "'" + _id_estilo + "'" : "null") +
            "    )";
        
        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);

        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }

    public int delete(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    DELETE FROM estilo" +
            "    WHERE" +
            "    id_estilo = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
}

DEBUG [main] (SQLiteORM.java:139) - table: info_sincro
DEBUG [main] (SQLiteORM.java:150) - columns:
/**
 * 
 */
package bd;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.AbstractMap;
import java.util.ArrayList;

/**
 * @author petete-ntbk
 *
 */
public class Info_sincro {
private Integer _id;
private String _fecha;
private String _fecha_fin_procesamiento;
private Integer _sentido;
private String _fecha_lectura;
private String _archivo_nombre;
private String _archivo_md5;
private Integer _archivo_tamano;

    private final static String _str_sql = 
        "    SELECT" +
        "    in.id_info_sincro AS id," +
        "    in.fecha AS fecha," +
        "    in.fecha_fin_procesamiento AS fecha_fin_procesamiento," +
        "    in.sentido AS sentido," +
        "    in.fecha_lectura AS fecha_lectura," +
        "    in.archivo_nombre AS archivo_nombre," +
        "    in.archivo_md5 AS archivo_md5," +
        "    in.archivo_tamano AS archivo_tamano" +
        "    FROM info_sincro in";

    public Info_sincro() {
        _id = null;
        _fecha = null;
        _fecha_fin_procesamiento = null;
        _sentido = null;
        _fecha_lectura = null;
        _archivo_nombre = null;
        _archivo_md5 = null;
        _archivo_tamano = null;

    }
    /**
     * @return the _id
     */
    public Integer get_id() {
        return _id;
    }
    /**
     * @return the _fecha
     */
    public String get_fecha() {
        return _fecha;
    }
    /**
     * @return the _fecha_fin_procesamiento
     */
    public String get_fecha_fin_procesamiento() {
        return _fecha_fin_procesamiento;
    }
    /**
     * @return the _sentido
     */
    public Integer get_sentido() {
        return _sentido;
    }
    /**
     * @return the _fecha_lectura
     */
    public String get_fecha_lectura() {
        return _fecha_lectura;
    }
    /**
     * @return the _archivo_nombre
     */
    public String get_archivo_nombre() {
        return _archivo_nombre;
    }
    /**
     * @return the _archivo_md5
     */
    public String get_archivo_md5() {
        return _archivo_md5;
    }
    /**
     * @return the _archivo_tamano
     */
    public Integer get_archivo_tamano() {
        return _archivo_tamano;
    }
    /**
     * @param _id the _id to set
     */
    public void set_id(Integer _id) {
        this._id = _id;
    }
    /**
     * @param _fecha the _fecha to set
     */
    public void set_fecha(String _fecha) {
        this._fecha = _fecha;
    }
    /**
     * @param _fecha_fin_procesamiento the _fecha_fin_procesamiento to set
     */
    public void set_fecha_fin_procesamiento(String _fecha_fin_procesamiento) {
        this._fecha_fin_procesamiento = _fecha_fin_procesamiento;
    }
    /**
     * @param _sentido the _sentido to set
     */
    public void set_sentido(Integer _sentido) {
        this._sentido = _sentido;
    }
    /**
     * @param _fecha_lectura the _fecha_lectura to set
     */
    public void set_fecha_lectura(String _fecha_lectura) {
        this._fecha_lectura = _fecha_lectura;
    }
    /**
     * @param _archivo_nombre the _archivo_nombre to set
     */
    public void set_archivo_nombre(String _archivo_nombre) {
        this._archivo_nombre = _archivo_nombre;
    }
    /**
     * @param _archivo_md5 the _archivo_md5 to set
     */
    public void set_archivo_md5(String _archivo_md5) {
        this._archivo_md5 = _archivo_md5;
    }
    /**
     * @param _archivo_tamano the _archivo_tamano to set
     */
    public void set_archivo_tamano(Integer _archivo_tamano) {
        this._archivo_tamano = _archivo_tamano;
    }

    public static Info_sincro fromRS(ResultSet p_rs) throws SQLException {
        Info_sincro ret = new Info_sincro();

        ret.set_id(p_rs.getInt("id"));
        ret.set_fecha(p_rs.getString("fecha"));
        ret.set_fecha_fin_procesamiento(p_rs.getString("fecha_fin_procesamiento"));
        ret.set_sentido(p_rs.getInt("sentido"));
        ret.set_fecha_lectura(p_rs.getString("fecha_lectura"));
        ret.set_archivo_nombre(p_rs.getString("archivo_nombre"));
        ret.set_archivo_md5(p_rs.getString("archivo_md5"));
        ret.set_archivo_tamano(p_rs.getInt("archivo_tamano"));

        return ret;
    }

    public static Info_sincro getByParameter(Connection p_conn, String p_key, String p_value) throws SQLException {
        Info_sincro ret = null;
        
        String str_sql = _str_sql +
            "  WHERE in." + p_key + " = " + p_value +
            "  LIMIT 0, 1";
        
        //System.out.println(str_sql);
        
        // assume that conn is an already created JDBC connection (see previous examples)
        Statement stmt = null;
        ResultSet rs = null;
        
        try {
            stmt = p_conn.createStatement();
            //System.out.println("stmt = p_conn.createStatement() ok");
            rs = stmt.executeQuery(str_sql);
            //System.out.println("rs = stmt.executeQuery(str_sql) ok");

            // Now do something with the ResultSet ....
            
            if (rs.next()) {
                //System.out.println("rs.next() ok");
                ret = fromRS(rs);
                //System.out.println("fromRS(rs) ok");
            }
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        
        
        return ret;        
    }

    public static Info_sincro getById(Connection p_conn, String p_id) throws Exception {
        return getByParameter(p_conn, "id_info_sincro", p_id);
    }
    
    public static ArrayList<Info_sincro> seek(Connection p_conn, ArrayList<AbstractMap.SimpleEntry<String, String>> p_parameters, String p_order, String p_direction, int p_offset, int p_limit) throws Exception {
        Statement stmt = null;
        ResultSet rs = null;
        String str_sql;
        ArrayList<Info_sincro> ret;
        
        str_sql = "";
        
        try {
            ArrayList<String> array_clauses = new ArrayList<String>();
            
            ret = new ArrayList<Info_sincro>();
            
            str_sql = _str_sql;
            
            for (AbstractMap.SimpleEntry<String, String> p : p_parameters) {
                if (p.getKey().equals("id_info_sincro")) {
                    array_clauses.add("in.id_info_sincro = " + p.getValue());
                }
                else {
                    throw new Exception("Parametro no soportado: " + p.getKey());
                }
            }
                                
            boolean bFirstTime = false;
            
            for(String clause : array_clauses) {
                if (!bFirstTime) {
                     bFirstTime = true;
                     str_sql += " WHERE ";
                }
                else {
                     str_sql += " AND ";
                }
                str_sql += clause;
            }
            
            if (p_order != null && p_direction != null) {
                str_sql += " ORDER BY " + p_order + " " + p_direction;
            }
            
            if (p_offset != -1 && p_limit != -1) {
                str_sql += "  LIMIT " +  Integer.toString(p_offset) + ", " + Integer.toString(p_limit);
            }
            
            //echo "<br>" . str_sql . "<br>";
        
            stmt = p_conn.createStatement();
            
            rs = stmt.executeQuery(str_sql);
            
            while (rs.next()) {
                ret.add(fromRS(rs));
            }
            /*
            if (ret.size() == 0) {
                ret = null;
            }
            */
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        catch (Exception ex) {
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        

        return ret;
    }

    public int update(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    UPDATE info_sincro" +
            "    SET" +
            "    fecha = " + (_fecha != null ? "'" + _fecha + "'" : "null") + "," +
            "    fecha_fin_procesamiento = " + (_fecha_fin_procesamiento != null ? "'" + _fecha_fin_procesamiento + "'" : "null") + "," +
            "    sentido = " + (_sentido != null ? _sentido : "null") + "," +
            "    fecha_lectura = " + (_fecha_lectura != null ? "'" + _fecha_lectura + "'" : "null") + "," +
            "    archivo_nombre = " + (_archivo_nombre != null ? "'" + _archivo_nombre + "'" : "null") + "," +
            "    archivo_md5 = " + (_archivo_md5 != null ? "'" + _archivo_md5 + "'" : "null") + "," +
            "    archivo_tamano = " + (_archivo_tamano != null ? _archivo_tamano : "null") +
            "    WHERE" +
            "    id_info_sincro = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
            /*
            if (stmt.executeUpdate(str_sql) < 1) {
                throw new Exception("No hubo filas afectadas");
            }
            */
            
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
    
    public int insert(Connection p_conn) throws SQLException {
        
        int ret = -1;
        Statement stmt = null;
        ResultSet rs = null;

        String str_sql =
            "    INSERT INTO info_sincro" +
            "    (" +
            "    id_info_sincro, " +
            "    fecha, " +
            "    fecha_fin_procesamiento, " +
            "    sentido, " +
            "    fecha_lectura, " +
            "    archivo_nombre, " +
            "    archivo_md5, " +
            "    archivo_tamano)" +
            "    VALUES" +
            "    (" +
            "    " + (_id_info_sincro != null ? "'" + _id_info_sincro + "'" : "null") + "," +
            "    " + (_fecha != null ? "'" + _fecha + "'" : "null") + "," +
            "    " + (_fecha_fin_procesamiento != null ? "'" + _fecha_fin_procesamiento + "'" : "null") + "," +
            "    " + (_sentido != null ? "'" + _sentido + "'" : "null") + "," +
            "    " + (_fecha_lectura != null ? "'" + _fecha_lectura + "'" : "null") + "," +
            "    " + (_archivo_nombre != null ? "'" + _archivo_nombre + "'" : "null") + "," +
            "    " + (_archivo_md5 != null ? "'" + _archivo_md5 + "'" : "null") + "," +
            "    " + (_archivo_tamano != null ? "'" + _archivo_tamano + "'" : "null") +
            "    )";
        
        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);

        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }

    public int delete(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    DELETE FROM info_sincro" +
            "    WHERE" +
            "    id_info_sincro = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
}

DEBUG [main] (SQLiteORM.java:139) - table: log
DEBUG [main] (SQLiteORM.java:150) - columns:
/**
 * 
 */
package bd;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.AbstractMap;
import java.util.ArrayList;

/**
 * @author petete-ntbk
 *
 */
public class Log {
private Integer _id_tipo_vehiculo;
private String _fecha;
private Integer _id_usuario;
private Integer _id_vehiculo;
private Float _latitud;
private Integer _id_log;
private Integer _id_modelo;
private Float _longitud;
private String _accion;
private Integer _km;
private Integer _id_marca;

    private final static String _str_sql = 
        "    SELECT" +
        "    lo.id_tipo_vehiculo AS id_tipo_vehiculo," +
        "    lo.fecha AS fecha," +
        "    lo.id_usuario AS id_usuario," +
        "    lo.id_vehiculo AS id_vehiculo," +
        "    lo.latitud AS latitud," +
        "    lo.id_log AS id_log," +
        "    lo.id_modelo AS id_modelo," +
        "    lo.longitud AS longitud," +
        "    lo.accion AS accion," +
        "    lo.km AS km," +
        "    lo.id_marca AS id_marca" +
        "    FROM log lo";

    public Log() {
        _id_tipo_vehiculo = null;
        _fecha = null;
        _id_usuario = null;
        _id_vehiculo = null;
        _latitud = null;
        _id_log = null;
        _id_modelo = null;
        _longitud = null;
        _accion = null;
        _km = null;
        _id_marca = null;

    }
    /**
     * @return the _id_tipo_vehiculo
     */
    public Integer get_id_tipo_vehiculo() {
        return _id_tipo_vehiculo;
    }
    /**
     * @return the _fecha
     */
    public String get_fecha() {
        return _fecha;
    }
    /**
     * @return the _id_usuario
     */
    public Integer get_id_usuario() {
        return _id_usuario;
    }
    /**
     * @return the _id_vehiculo
     */
    public Integer get_id_vehiculo() {
        return _id_vehiculo;
    }
    /**
     * @return the _latitud
     */
    public Float get_latitud() {
        return _latitud;
    }
    /**
     * @return the _id_log
     */
    public Integer get_id_log() {
        return _id_log;
    }
    /**
     * @return the _id_modelo
     */
    public Integer get_id_modelo() {
        return _id_modelo;
    }
    /**
     * @return the _longitud
     */
    public Float get_longitud() {
        return _longitud;
    }
    /**
     * @return the _accion
     */
    public String get_accion() {
        return _accion;
    }
    /**
     * @return the _km
     */
    public Integer get_km() {
        return _km;
    }
    /**
     * @return the _id_marca
     */
    public Integer get_id_marca() {
        return _id_marca;
    }
    /**
     * @param _id_tipo_vehiculo the _id_tipo_vehiculo to set
     */
    public void set_id_tipo_vehiculo(Integer _id_tipo_vehiculo) {
        this._id_tipo_vehiculo = _id_tipo_vehiculo;
    }
    /**
     * @param _fecha the _fecha to set
     */
    public void set_fecha(String _fecha) {
        this._fecha = _fecha;
    }
    /**
     * @param _id_usuario the _id_usuario to set
     */
    public void set_id_usuario(Integer _id_usuario) {
        this._id_usuario = _id_usuario;
    }
    /**
     * @param _id_vehiculo the _id_vehiculo to set
     */
    public void set_id_vehiculo(Integer _id_vehiculo) {
        this._id_vehiculo = _id_vehiculo;
    }
    /**
     * @param _latitud the _latitud to set
     */
    public void set_latitud(Float _latitud) {
        this._latitud = _latitud;
    }
    /**
     * @param _id_log the _id_log to set
     */
    public void set_id_log(Integer _id_log) {
        this._id_log = _id_log;
    }
    /**
     * @param _id_modelo the _id_modelo to set
     */
    public void set_id_modelo(Integer _id_modelo) {
        this._id_modelo = _id_modelo;
    }
    /**
     * @param _longitud the _longitud to set
     */
    public void set_longitud(Float _longitud) {
        this._longitud = _longitud;
    }
    /**
     * @param _accion the _accion to set
     */
    public void set_accion(String _accion) {
        this._accion = _accion;
    }
    /**
     * @param _km the _km to set
     */
    public void set_km(Integer _km) {
        this._km = _km;
    }
    /**
     * @param _id_marca the _id_marca to set
     */
    public void set_id_marca(Integer _id_marca) {
        this._id_marca = _id_marca;
    }

    public static Log fromRS(ResultSet p_rs) throws SQLException {
        Log ret = new Log();

        ret.set_id_tipo_vehiculo(p_rs.getInt("id_tipo_vehiculo"));
        ret.set_fecha(p_rs.getString("fecha"));
        ret.set_id_usuario(p_rs.getInt("id_usuario"));
        ret.set_id_vehiculo(p_rs.getInt("id_vehiculo"));
        ret.set_latitud(p_rs.getFloat("latitud"));
        ret.set_id_log(p_rs.getInt("id_log"));
        ret.set_id_modelo(p_rs.getInt("id_modelo"));
        ret.set_longitud(p_rs.getFloat("longitud"));
        ret.set_accion(p_rs.getString("accion"));
        ret.set_km(p_rs.getInt("km"));
        ret.set_id_marca(p_rs.getInt("id_marca"));

        return ret;
    }

    public static Log getByParameter(Connection p_conn, String p_key, String p_value) throws SQLException {
        Log ret = null;
        
        String str_sql = _str_sql +
            "  WHERE lo." + p_key + " = " + p_value +
            "  LIMIT 0, 1";
        
        //System.out.println(str_sql);
        
        // assume that conn is an already created JDBC connection (see previous examples)
        Statement stmt = null;
        ResultSet rs = null;
        
        try {
            stmt = p_conn.createStatement();
            //System.out.println("stmt = p_conn.createStatement() ok");
            rs = stmt.executeQuery(str_sql);
            //System.out.println("rs = stmt.executeQuery(str_sql) ok");

            // Now do something with the ResultSet ....
            
            if (rs.next()) {
                //System.out.println("rs.next() ok");
                ret = fromRS(rs);
                //System.out.println("fromRS(rs) ok");
            }
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        
        
        return ret;        
    }

    
    public static ArrayList<Log> seek(Connection p_conn, ArrayList<AbstractMap.SimpleEntry<String, String>> p_parameters, String p_order, String p_direction, int p_offset, int p_limit) throws Exception {
        Statement stmt = null;
        ResultSet rs = null;
        String str_sql;
        ArrayList<Log> ret;
        
        str_sql = "";
        
        try {
            ArrayList<String> array_clauses = new ArrayList<String>();
            
            ret = new ArrayList<Log>();
            
            str_sql = _str_sql;
            
            for (AbstractMap.SimpleEntry<String, String> p : p_parameters) {
                if (p.getKey().equals("id_usuario")) {
                    array_clauses.add("lo.id_usuario = " + p.getValue());
                }
                else if (p.getKey().equals("id_log")) {
                    array_clauses.add("lo.id_log = " + p.getValue());
                }
                else {
                    throw new Exception("Parametro no soportado: " + p.getKey());
                }
            }
                                
            boolean bFirstTime = false;
            
            for(String clause : array_clauses) {
                if (!bFirstTime) {
                     bFirstTime = true;
                     str_sql += " WHERE ";
                }
                else {
                     str_sql += " AND ";
                }
                str_sql += clause;
            }
            
            if (p_order != null && p_direction != null) {
                str_sql += " ORDER BY " + p_order + " " + p_direction;
            }
            
            if (p_offset != -1 && p_limit != -1) {
                str_sql += "  LIMIT " +  Integer.toString(p_offset) + ", " + Integer.toString(p_limit);
            }
            
            //echo "<br>" . str_sql . "<br>";
        
            stmt = p_conn.createStatement();
            
            rs = stmt.executeQuery(str_sql);
            
            while (rs.next()) {
                ret.add(fromRS(rs));
            }
            /*
            if (ret.size() == 0) {
                ret = null;
            }
            */
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        catch (Exception ex) {
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        

        return ret;
    }

    public int update(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    UPDATE log" +
            "    SET" +
            "    id_tipo_vehiculo = " + (_id_tipo_vehiculo != null ? _id_tipo_vehiculo : "null") + "," +
            "    fecha = " + (_fecha != null ? "'" + _fecha + "'" : "null") + "," +
            "    id_vehiculo = " + (_id_vehiculo != null ? _id_vehiculo : "null") + "," +
            "    latitud = " + (_latitud != null ? _latitud : "null") + "," +
            "    id_modelo = " + (_id_modelo != null ? _id_modelo : "null") + "," +
            "    longitud = " + (_longitud != null ? _longitud : "null") + "," +
            "    accion = " + (_accion != null ? "'" + _accion + "'" : "null") + "," +
            "    km = " + (_km != null ? _km : "null") + "," +
            "    id_marca = " + (_id_marca != null ? _id_marca : "null") +
            "    WHERE" +
            "    id_usuario = Integer.toString(this._id_usuario)" AND
            "    id_log = Integer.toString(this._id_log)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
            /*
            if (stmt.executeUpdate(str_sql) < 1) {
                throw new Exception("No hubo filas afectadas");
            }
            */
            
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
    
    public int insert(Connection p_conn) throws SQLException {
        
        int ret = -1;
        Statement stmt = null;
        ResultSet rs = null;

        String str_sql =
            "    INSERT INTO log" +
            "    (" +
            "    id_tipo_vehiculo, " +
            "    id_usuario, " +
            "    id_vehiculo, " +
            "    latitud, " +
            "    id_log, " +
            "    id_modelo, " +
            "    longitud, " +
            "    accion, " +
            "    km, " +
            "    id_marca)" +
            "    VALUES" +
            "    (" +
            "    " + (_id_tipo_vehiculo != null ? "'" + _id_tipo_vehiculo + "'" : "null") + "," +
            "    " + (_id_usuario != null ? "'" + _id_usuario + "'" : "null") + "," +
            "    " + (_id_vehiculo != null ? "'" + _id_vehiculo + "'" : "null") + "," +
            "    " + (_latitud != null ? "'" + _latitud + "'" : "null") + "," +
            "    " + (_id_log != null ? "'" + _id_log + "'" : "null") + "," +
            "    " + (_id_modelo != null ? "'" + _id_modelo + "'" : "null") + "," +
            "    " + (_longitud != null ? "'" + _longitud + "'" : "null") + "," +
            "    " + (_accion != null ? "'" + _accion + "'" : "null") + "," +
            "    " + (_km != null ? "'" + _km + "'" : "null") + "," +
            "    " + (_id_marca != null ? "'" + _id_marca + "'" : "null") +
            "    )";
        
        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);

        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }

    public int delete(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    DELETE FROM log" +
            "    WHERE" +
            "    id_usuario = Integer.toString(this._id_usuario)" AND
            "    id_log = Integer.toString(this._id_log)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
}

DEBUG [main] (SQLiteORM.java:139) - table: mantencion_base
DEBUG [main] (SQLiteORM.java:150) - columns:
/**
 * 
 */
package bd;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.AbstractMap;
import java.util.ArrayList;

/**
 * @author petete-ntbk
 *
 */
public class Mantencion_base {
private Integer _dias_entre_mantenciones;
private String _tipo_transmision;
private String _codigo_motor;
private Integer _km_entre_mantenciones;
private String _depende_km;
private String _accion;
private String _url;
private String _descripcion_item;
private String _fecha_modificacion;
private Integer _id_modelo_anio;
private Integer _id;
private String _item;
private String _tipo_traccion;
private String _beneficios;

    private final static String _str_sql = 
        "    SELECT" +
        "    ma.dias_entre_mantenciones AS dias_entre_mantenciones," +
        "    ma.tipo_transmision AS tipo_transmision," +
        "    ma.codigo_motor AS codigo_motor," +
        "    ma.km_entre_mantenciones AS km_entre_mantenciones," +
        "    ma.depende_km AS depende_km," +
        "    ma.accion AS accion," +
        "    ma.url AS url," +
        "    ma.descripcion_item AS descripcion_item," +
        "    ma.fecha_modificacion AS fecha_modificacion," +
        "    ma.id_modelo_anio AS id_modelo_anio," +
        "    ma.id_mantencion_base AS id," +
        "    ma.item AS item," +
        "    ma.tipo_traccion AS tipo_traccion," +
        "    ma.beneficios AS beneficios" +
        "    FROM mantencion_base ma";

    public Mantencion_base() {
        _dias_entre_mantenciones = null;
        _tipo_transmision = null;
        _codigo_motor = null;
        _km_entre_mantenciones = null;
        _depende_km = null;
        _accion = null;
        _url = null;
        _descripcion_item = null;
        _fecha_modificacion = null;
        _id_modelo_anio = null;
        _id = null;
        _item = null;
        _tipo_traccion = null;
        _beneficios = null;

    }
    /**
     * @return the _dias_entre_mantenciones
     */
    public Integer get_dias_entre_mantenciones() {
        return _dias_entre_mantenciones;
    }
    /**
     * @return the _tipo_transmision
     */
    public String get_tipo_transmision() {
        return _tipo_transmision;
    }
    /**
     * @return the _codigo_motor
     */
    public String get_codigo_motor() {
        return _codigo_motor;
    }
    /**
     * @return the _km_entre_mantenciones
     */
    public Integer get_km_entre_mantenciones() {
        return _km_entre_mantenciones;
    }
    /**
     * @return the _depende_km
     */
    public String get_depende_km() {
        return _depende_km;
    }
    /**
     * @return the _accion
     */
    public String get_accion() {
        return _accion;
    }
    /**
     * @return the _url
     */
    public String get_url() {
        return _url;
    }
    /**
     * @return the _descripcion_item
     */
    public String get_descripcion_item() {
        return _descripcion_item;
    }
    /**
     * @return the _fecha_modificacion
     */
    public String get_fecha_modificacion() {
        return _fecha_modificacion;
    }
    /**
     * @return the _id_modelo_anio
     */
    public Integer get_id_modelo_anio() {
        return _id_modelo_anio;
    }
    /**
     * @return the _id
     */
    public Integer get_id() {
        return _id;
    }
    /**
     * @return the _item
     */
    public String get_item() {
        return _item;
    }
    /**
     * @return the _tipo_traccion
     */
    public String get_tipo_traccion() {
        return _tipo_traccion;
    }
    /**
     * @return the _beneficios
     */
    public String get_beneficios() {
        return _beneficios;
    }
    /**
     * @param _dias_entre_mantenciones the _dias_entre_mantenciones to set
     */
    public void set_dias_entre_mantenciones(Integer _dias_entre_mantenciones) {
        this._dias_entre_mantenciones = _dias_entre_mantenciones;
    }
    /**
     * @param _tipo_transmision the _tipo_transmision to set
     */
    public void set_tipo_transmision(String _tipo_transmision) {
        this._tipo_transmision = _tipo_transmision;
    }
    /**
     * @param _codigo_motor the _codigo_motor to set
     */
    public void set_codigo_motor(String _codigo_motor) {
        this._codigo_motor = _codigo_motor;
    }
    /**
     * @param _km_entre_mantenciones the _km_entre_mantenciones to set
     */
    public void set_km_entre_mantenciones(Integer _km_entre_mantenciones) {
        this._km_entre_mantenciones = _km_entre_mantenciones;
    }
    /**
     * @param _depende_km the _depende_km to set
     */
    public void set_depende_km(String _depende_km) {
        this._depende_km = _depende_km;
    }
    /**
     * @param _accion the _accion to set
     */
    public void set_accion(String _accion) {
        this._accion = _accion;
    }
    /**
     * @param _url the _url to set
     */
    public void set_url(String _url) {
        this._url = _url;
    }
    /**
     * @param _descripcion_item the _descripcion_item to set
     */
    public void set_descripcion_item(String _descripcion_item) {
        this._descripcion_item = _descripcion_item;
    }
    /**
     * @param _fecha_modificacion the _fecha_modificacion to set
     */
    public void set_fecha_modificacion(String _fecha_modificacion) {
        this._fecha_modificacion = _fecha_modificacion;
    }
    /**
     * @param _id_modelo_anio the _id_modelo_anio to set
     */
    public void set_id_modelo_anio(Integer _id_modelo_anio) {
        this._id_modelo_anio = _id_modelo_anio;
    }
    /**
     * @param _id the _id to set
     */
    public void set_id(Integer _id) {
        this._id = _id;
    }
    /**
     * @param _item the _item to set
     */
    public void set_item(String _item) {
        this._item = _item;
    }
    /**
     * @param _tipo_traccion the _tipo_traccion to set
     */
    public void set_tipo_traccion(String _tipo_traccion) {
        this._tipo_traccion = _tipo_traccion;
    }
    /**
     * @param _beneficios the _beneficios to set
     */
    public void set_beneficios(String _beneficios) {
        this._beneficios = _beneficios;
    }

    public static Mantencion_base fromRS(ResultSet p_rs) throws SQLException {
        Mantencion_base ret = new Mantencion_base();

        ret.set_dias_entre_mantenciones(p_rs.getInt("dias_entre_mantenciones"));
        ret.set_tipo_transmision(p_rs.getString("tipo_transmision"));
        ret.set_codigo_motor(p_rs.getString("codigo_motor"));
        ret.set_km_entre_mantenciones(p_rs.getInt("km_entre_mantenciones"));
        ret.set_depende_km(p_rs.getString("depende_km"));
        ret.set_accion(p_rs.getString("accion"));
        ret.set_url(p_rs.getString("url"));
        ret.set_descripcion_item(p_rs.getString("descripcion_item"));
        ret.set_fecha_modificacion(p_rs.getString("fecha_modificacion"));
        ret.set_id_modelo_anio(p_rs.getInt("id_modelo_anio"));
        ret.set_id(p_rs.getInt("id"));
        ret.set_item(p_rs.getString("item"));
        ret.set_tipo_traccion(p_rs.getString("tipo_traccion"));
        ret.set_beneficios(p_rs.getString("beneficios"));

        return ret;
    }

    public static Mantencion_base getByParameter(Connection p_conn, String p_key, String p_value) throws SQLException {
        Mantencion_base ret = null;
        
        String str_sql = _str_sql +
            "  WHERE ma." + p_key + " = " + p_value +
            "  LIMIT 0, 1";
        
        //System.out.println(str_sql);
        
        // assume that conn is an already created JDBC connection (see previous examples)
        Statement stmt = null;
        ResultSet rs = null;
        
        try {
            stmt = p_conn.createStatement();
            //System.out.println("stmt = p_conn.createStatement() ok");
            rs = stmt.executeQuery(str_sql);
            //System.out.println("rs = stmt.executeQuery(str_sql) ok");

            // Now do something with the ResultSet ....
            
            if (rs.next()) {
                //System.out.println("rs.next() ok");
                ret = fromRS(rs);
                //System.out.println("fromRS(rs) ok");
            }
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        
        
        return ret;        
    }

    public static Mantencion_base getById(Connection p_conn, String p_id) throws Exception {
        return getByParameter(p_conn, "id_mantencion_base", p_id);
    }
    
    public static ArrayList<Mantencion_base> seek(Connection p_conn, ArrayList<AbstractMap.SimpleEntry<String, String>> p_parameters, String p_order, String p_direction, int p_offset, int p_limit) throws Exception {
        Statement stmt = null;
        ResultSet rs = null;
        String str_sql;
        ArrayList<Mantencion_base> ret;
        
        str_sql = "";
        
        try {
            ArrayList<String> array_clauses = new ArrayList<String>();
            
            ret = new ArrayList<Mantencion_base>();
            
            str_sql = _str_sql;
            
            for (AbstractMap.SimpleEntry<String, String> p : p_parameters) {
                if (p.getKey().equals("id_mantencion_base")) {
                    array_clauses.add("ma.id_mantencion_base = " + p.getValue());
                }
                else if (p.getKey().equals("id_modelo_anio")) {
                    array_clauses.add("ma.id_modelo_anio = " + p.getValue());
                }
                else if (p.getKey().equals("mas reciente")) {
                    array_clauses.add("ma.fecha_modificacion > STR_TO_DATE('" + p.getValue() + "', '%d-%m-%Y %H:%i:%s')");
                }
                else {
                    throw new Exception("Parametro no soportado: " + p.getKey());
                }
            }
                                
            boolean bFirstTime = false;
            
            for(String clause : array_clauses) {
                if (!bFirstTime) {
                     bFirstTime = true;
                     str_sql += " WHERE ";
                }
                else {
                     str_sql += " AND ";
                }
                str_sql += clause;
            }
            
            if (p_order != null && p_direction != null) {
                str_sql += " ORDER BY " + p_order + " " + p_direction;
            }
            
            if (p_offset != -1 && p_limit != -1) {
                str_sql += "  LIMIT " +  Integer.toString(p_offset) + ", " + Integer.toString(p_limit);
            }
            
            //echo "<br>" . str_sql . "<br>";
        
            stmt = p_conn.createStatement();
            
            rs = stmt.executeQuery(str_sql);
            
            while (rs.next()) {
                ret.add(fromRS(rs));
            }
            /*
            if (ret.size() == 0) {
                ret = null;
            }
            */
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        catch (Exception ex) {
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        

        return ret;
    }

    public int update(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    UPDATE mantencion_base" +
            "    SET" +
            "    dias_entre_mantenciones = " + (_dias_entre_mantenciones != null ? _dias_entre_mantenciones : "null") + "," +
            "    tipo_transmision = " + (_tipo_transmision != null ? "'" + _tipo_transmision + "'" : "null") + "," +
            "    codigo_motor = " + (_codigo_motor != null ? "'" + _codigo_motor + "'" : "null") + "," +
            "    km_entre_mantenciones = " + (_km_entre_mantenciones != null ? _km_entre_mantenciones : "null") + "," +
            "    depende_km = " + (_depende_km != null ? "'" + _depende_km + "'" : "null") + "," +
            "    accion = " + (_accion != null ? "'" + _accion + "'" : "null") + "," +
            "    url = " + (_url != null ? "'" + _url + "'" : "null") + "," +
            "    descripcion_item = " + (_descripcion_item != null ? "'" + _descripcion_item + "'" : "null") + "," +
            "    fecha_modificacion = " + (_fecha_modificacion != null ? "'" + _fecha_modificacion + "'" : "null") + "," +
            "    item = " + (_item != null ? "'" + _item + "'" : "null") + "," +
            "    tipo_traccion = " + (_tipo_traccion != null ? "'" + _tipo_traccion + "'" : "null") + "," +
            "    beneficios = " + (_beneficios != null ? "'" + _beneficios + "'" : "null") +
            "    WHERE" +
            "    id_mantencion_base = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
            /*
            if (stmt.executeUpdate(str_sql) < 1) {
                throw new Exception("No hubo filas afectadas");
            }
            */
            
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
    
    public int insert(Connection p_conn) throws SQLException {
        
        int ret = -1;
        Statement stmt = null;
        ResultSet rs = null;

        String str_sql =
            "    INSERT INTO mantencion_base" +
            "    (" +
            "    dias_entre_mantenciones, " +
            "    tipo_transmision, " +
            "    codigo_motor, " +
            "    km_entre_mantenciones, " +
            "    depende_km, " +
            "    accion, " +
            "    url, " +
            "    descripcion_item, " +
            "    id_modelo_anio, " +
            "    id_mantencion_base, " +
            "    item, " +
            "    tipo_traccion, " +
            "    beneficios)" +
            "    VALUES" +
            "    (" +
            "    " + (_dias_entre_mantenciones != null ? "'" + _dias_entre_mantenciones + "'" : "null") + "," +
            "    " + (_tipo_transmision != null ? "'" + _tipo_transmision + "'" : "null") + "," +
            "    " + (_codigo_motor != null ? "'" + _codigo_motor + "'" : "null") + "," +
            "    " + (_km_entre_mantenciones != null ? "'" + _km_entre_mantenciones + "'" : "null") + "," +
            "    " + (_depende_km != null ? "'" + _depende_km + "'" : "null") + "," +
            "    " + (_accion != null ? "'" + _accion + "'" : "null") + "," +
            "    " + (_url != null ? "'" + _url + "'" : "null") + "," +
            "    " + (_descripcion_item != null ? "'" + _descripcion_item + "'" : "null") + "," +
            "    " + (_id_modelo_anio != null ? "'" + _id_modelo_anio + "'" : "null") + "," +
            "    " + (_id_mantencion_base != null ? "'" + _id_mantencion_base + "'" : "null") + "," +
            "    " + (_item != null ? "'" + _item + "'" : "null") + "," +
            "    " + (_tipo_traccion != null ? "'" + _tipo_traccion + "'" : "null") + "," +
            "    " + (_beneficios != null ? "'" + _beneficios + "'" : "null") +
            "    )";
        
        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);

        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }

    public int delete(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    DELETE FROM mantencion_base" +
            "    WHERE" +
            "    id_mantencion_base = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
}

DEBUG [main] (SQLiteORM.java:139) - table: mantencion_usuario
DEBUG [main] (SQLiteORM.java:150) - columns:
/**
 * 
 */
package bd;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.AbstractMap;
import java.util.ArrayList;

/**
 * @author petete-ntbk
 *
 */
public class Mantencion_usuario {
private Integer _KmEntreMantenciones;
private String _descripcion;
private Integer _id_mantencion_usuario;
private String _mantencion_usuariocol;
private String _DependeKm;
private Integer _mantecion_base;
private String _nombre;
private String _MantencionUsuariocol;
private String _fecha_modificacion;
private Integer _id_usuario;
private Integer _id_mantencion_base;
private Integer _id_vehiculo;
private Integer _DiasEntreMantenciones;
private String _URL;
private String _beneficios;

    private final static String _str_sql = 
        "    SELECT" +
        "    ma.KmEntreMantenciones AS KmEntreMantenciones," +
        "    ma.descripcion AS descripcion," +
        "    ma.id_mantencion_usuario AS id_mantencion_usuario," +
        "    ma.mantencion_usuariocol AS mantencion_usuariocol," +
        "    ma.DependeKm AS DependeKm," +
        "    ma.mantecion_base AS mantecion_base," +
        "    ma.nombre AS nombre," +
        "    ma.MantencionUsuariocol AS MantencionUsuariocol," +
        "    ma.fecha_modificacion AS fecha_modificacion," +
        "    ma.id_usuario AS id_usuario," +
        "    ma.id_mantencion_base AS id_mantencion_base," +
        "    ma.id_vehiculo AS id_vehiculo," +
        "    ma.DiasEntreMantenciones AS DiasEntreMantenciones," +
        "    ma.URL AS URL," +
        "    ma.beneficios AS beneficios" +
        "    FROM mantencion_usuario ma";

    public Mantencion_usuario() {
        _KmEntreMantenciones = null;
        _descripcion = null;
        _id_mantencion_usuario = null;
        _mantencion_usuariocol = null;
        _DependeKm = null;
        _mantecion_base = null;
        _nombre = null;
        _MantencionUsuariocol = null;
        _fecha_modificacion = null;
        _id_usuario = null;
        _id_mantencion_base = null;
        _id_vehiculo = null;
        _DiasEntreMantenciones = null;
        _URL = null;
        _beneficios = null;

    }
    /**
     * @return the _KmEntreMantenciones
     */
    public Integer get_KmEntreMantenciones() {
        return _KmEntreMantenciones;
    }
    /**
     * @return the _descripcion
     */
    public String get_descripcion() {
        return _descripcion;
    }
    /**
     * @return the _id_mantencion_usuario
     */
    public Integer get_id_mantencion_usuario() {
        return _id_mantencion_usuario;
    }
    /**
     * @return the _mantencion_usuariocol
     */
    public String get_mantencion_usuariocol() {
        return _mantencion_usuariocol;
    }
    /**
     * @return the _DependeKm
     */
    public String get_DependeKm() {
        return _DependeKm;
    }
    /**
     * @return the _mantecion_base
     */
    public Integer get_mantecion_base() {
        return _mantecion_base;
    }
    /**
     * @return the _nombre
     */
    public String get_nombre() {
        return _nombre;
    }
    /**
     * @return the _MantencionUsuariocol
     */
    public String get_MantencionUsuariocol() {
        return _MantencionUsuariocol;
    }
    /**
     * @return the _fecha_modificacion
     */
    public String get_fecha_modificacion() {
        return _fecha_modificacion;
    }
    /**
     * @return the _id_usuario
     */
    public Integer get_id_usuario() {
        return _id_usuario;
    }
    /**
     * @return the _id_mantencion_base
     */
    public Integer get_id_mantencion_base() {
        return _id_mantencion_base;
    }
    /**
     * @return the _id_vehiculo
     */
    public Integer get_id_vehiculo() {
        return _id_vehiculo;
    }
    /**
     * @return the _DiasEntreMantenciones
     */
    public Integer get_DiasEntreMantenciones() {
        return _DiasEntreMantenciones;
    }
    /**
     * @return the _URL
     */
    public String get_URL() {
        return _URL;
    }
    /**
     * @return the _beneficios
     */
    public String get_beneficios() {
        return _beneficios;
    }
    /**
     * @param _KmEntreMantenciones the _KmEntreMantenciones to set
     */
    public void set_KmEntreMantenciones(Integer _KmEntreMantenciones) {
        this._KmEntreMantenciones = _KmEntreMantenciones;
    }
    /**
     * @param _descripcion the _descripcion to set
     */
    public void set_descripcion(String _descripcion) {
        this._descripcion = _descripcion;
    }
    /**
     * @param _id_mantencion_usuario the _id_mantencion_usuario to set
     */
    public void set_id_mantencion_usuario(Integer _id_mantencion_usuario) {
        this._id_mantencion_usuario = _id_mantencion_usuario;
    }
    /**
     * @param _mantencion_usuariocol the _mantencion_usuariocol to set
     */
    public void set_mantencion_usuariocol(String _mantencion_usuariocol) {
        this._mantencion_usuariocol = _mantencion_usuariocol;
    }
    /**
     * @param _DependeKm the _DependeKm to set
     */
    public void set_DependeKm(String _DependeKm) {
        this._DependeKm = _DependeKm;
    }
    /**
     * @param _mantecion_base the _mantecion_base to set
     */
    public void set_mantecion_base(Integer _mantecion_base) {
        this._mantecion_base = _mantecion_base;
    }
    /**
     * @param _nombre the _nombre to set
     */
    public void set_nombre(String _nombre) {
        this._nombre = _nombre;
    }
    /**
     * @param _MantencionUsuariocol the _MantencionUsuariocol to set
     */
    public void set_MantencionUsuariocol(String _MantencionUsuariocol) {
        this._MantencionUsuariocol = _MantencionUsuariocol;
    }
    /**
     * @param _fecha_modificacion the _fecha_modificacion to set
     */
    public void set_fecha_modificacion(String _fecha_modificacion) {
        this._fecha_modificacion = _fecha_modificacion;
    }
    /**
     * @param _id_usuario the _id_usuario to set
     */
    public void set_id_usuario(Integer _id_usuario) {
        this._id_usuario = _id_usuario;
    }
    /**
     * @param _id_mantencion_base the _id_mantencion_base to set
     */
    public void set_id_mantencion_base(Integer _id_mantencion_base) {
        this._id_mantencion_base = _id_mantencion_base;
    }
    /**
     * @param _id_vehiculo the _id_vehiculo to set
     */
    public void set_id_vehiculo(Integer _id_vehiculo) {
        this._id_vehiculo = _id_vehiculo;
    }
    /**
     * @param _DiasEntreMantenciones the _DiasEntreMantenciones to set
     */
    public void set_DiasEntreMantenciones(Integer _DiasEntreMantenciones) {
        this._DiasEntreMantenciones = _DiasEntreMantenciones;
    }
    /**
     * @param _URL the _URL to set
     */
    public void set_URL(String _URL) {
        this._URL = _URL;
    }
    /**
     * @param _beneficios the _beneficios to set
     */
    public void set_beneficios(String _beneficios) {
        this._beneficios = _beneficios;
    }

    public static Mantencion_usuario fromRS(ResultSet p_rs) throws SQLException {
        Mantencion_usuario ret = new Mantencion_usuario();

        ret.set_KmEntreMantenciones(p_rs.getInt("KmEntreMantenciones"));
        ret.set_descripcion(p_rs.getString("descripcion"));
        ret.set_id_mantencion_usuario(p_rs.getInt("id_mantencion_usuario"));
        ret.set_mantencion_usuariocol(p_rs.getString("mantencion_usuariocol"));
        ret.set_DependeKm(p_rs.getString("DependeKm"));
        ret.set_mantecion_base(p_rs.getInt("mantecion_base"));
        ret.set_nombre(p_rs.getString("nombre"));
        ret.set_MantencionUsuariocol(p_rs.getString("MantencionUsuariocol"));
        ret.set_fecha_modificacion(p_rs.getString("fecha_modificacion"));
        ret.set_id_usuario(p_rs.getInt("id_usuario"));
        ret.set_id_mantencion_base(p_rs.getInt("id_mantencion_base"));
        ret.set_id_vehiculo(p_rs.getInt("id_vehiculo"));
        ret.set_DiasEntreMantenciones(p_rs.getInt("DiasEntreMantenciones"));
        ret.set_URL(p_rs.getString("URL"));
        ret.set_beneficios(p_rs.getString("beneficios"));

        return ret;
    }

    public static Mantencion_usuario getByParameter(Connection p_conn, String p_key, String p_value) throws SQLException {
        Mantencion_usuario ret = null;
        
        String str_sql = _str_sql +
            "  WHERE ma." + p_key + " = " + p_value +
            "  LIMIT 0, 1";
        
        //System.out.println(str_sql);
        
        // assume that conn is an already created JDBC connection (see previous examples)
        Statement stmt = null;
        ResultSet rs = null;
        
        try {
            stmt = p_conn.createStatement();
            //System.out.println("stmt = p_conn.createStatement() ok");
            rs = stmt.executeQuery(str_sql);
            //System.out.println("rs = stmt.executeQuery(str_sql) ok");

            // Now do something with the ResultSet ....
            
            if (rs.next()) {
                //System.out.println("rs.next() ok");
                ret = fromRS(rs);
                //System.out.println("fromRS(rs) ok");
            }
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        
        
        return ret;        
    }

    
    public static ArrayList<Mantencion_usuario> seek(Connection p_conn, ArrayList<AbstractMap.SimpleEntry<String, String>> p_parameters, String p_order, String p_direction, int p_offset, int p_limit) throws Exception {
        Statement stmt = null;
        ResultSet rs = null;
        String str_sql;
        ArrayList<Mantencion_usuario> ret;
        
        str_sql = "";
        
        try {
            ArrayList<String> array_clauses = new ArrayList<String>();
            
            ret = new ArrayList<Mantencion_usuario>();
            
            str_sql = _str_sql;
            
            for (AbstractMap.SimpleEntry<String, String> p : p_parameters) {
                if (p.getKey().equals("id_usuario")) {
                    array_clauses.add("ma.id_usuario = " + p.getValue());
                }
                else if (p.getKey().equals("id_mantencion_usuario")) {
                    array_clauses.add("ma.id_mantencion_usuario = " + p.getValue());
                }
                else if (p.getKey().equals("id_usuario")) {
                    array_clauses.add("ma.id_usuario = " + p.getValue());
                }
                else if (p.getKey().equals("id_vehiculo")) {
                    array_clauses.add("ma.id_vehiculo = " + p.getValue());
                }
                else if (p.getKey().equals("mas reciente")) {
                    array_clauses.add("ma.fecha_modificacion > STR_TO_DATE('" + p.getValue() + "', '%d-%m-%Y %H:%i:%s')");
                }
                else {
                    throw new Exception("Parametro no soportado: " + p.getKey());
                }
            }
                                
            boolean bFirstTime = false;
            
            for(String clause : array_clauses) {
                if (!bFirstTime) {
                     bFirstTime = true;
                     str_sql += " WHERE ";
                }
                else {
                     str_sql += " AND ";
                }
                str_sql += clause;
            }
            
            if (p_order != null && p_direction != null) {
                str_sql += " ORDER BY " + p_order + " " + p_direction;
            }
            
            if (p_offset != -1 && p_limit != -1) {
                str_sql += "  LIMIT " +  Integer.toString(p_offset) + ", " + Integer.toString(p_limit);
            }
            
            //echo "<br>" . str_sql . "<br>";
        
            stmt = p_conn.createStatement();
            
            rs = stmt.executeQuery(str_sql);
            
            while (rs.next()) {
                ret.add(fromRS(rs));
            }
            /*
            if (ret.size() == 0) {
                ret = null;
            }
            */
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        catch (Exception ex) {
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        

        return ret;
    }

    public int update(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    UPDATE mantencion_usuario" +
            "    SET" +
            "    KmEntreMantenciones = " + (_KmEntreMantenciones != null ? _KmEntreMantenciones : "null") + "," +
            "    descripcion = " + (_descripcion != null ? "'" + _descripcion + "'" : "null") + "," +
            "    mantencion_usuariocol = " + (_mantencion_usuariocol != null ? "'" + _mantencion_usuariocol + "'" : "null") + "," +
            "    DependeKm = " + (_DependeKm != null ? "'" + _DependeKm + "'" : "null") + "," +
            "    mantecion_base = " + (_mantecion_base != null ? _mantecion_base : "null") + "," +
            "    nombre = " + (_nombre != null ? "'" + _nombre + "'" : "null") + "," +
            "    MantencionUsuariocol = " + (_MantencionUsuariocol != null ? "'" + _MantencionUsuariocol + "'" : "null") + "," +
            "    fecha_modificacion = " + (_fecha_modificacion != null ? "'" + _fecha_modificacion + "'" : "null") + "," +
            "    id_mantencion_base = " + (_id_mantencion_base != null ? _id_mantencion_base : "null") + "," +
            "    DiasEntreMantenciones = " + (_DiasEntreMantenciones != null ? _DiasEntreMantenciones : "null") + "," +
            "    URL = " + (_URL != null ? "'" + _URL + "'" : "null") + "," +
            "    beneficios = " + (_beneficios != null ? "'" + _beneficios + "'" : "null") +
            "    WHERE" +
            "    id_usuario = Integer.toString(this._id_usuario)" AND
            "    id_mantencion_usuario = Integer.toString(this._id_mantencion_usuario)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
            /*
            if (stmt.executeUpdate(str_sql) < 1) {
                throw new Exception("No hubo filas afectadas");
            }
            */
            
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
    
    public int insert(Connection p_conn) throws SQLException {
        
        int ret = -1;
        Statement stmt = null;
        ResultSet rs = null;

        String str_sql =
            "    INSERT INTO mantencion_usuario" +
            "    (" +
            "    KmEntreMantenciones, " +
            "    descripcion, " +
            "    id_mantencion_usuario, " +
            "    mantencion_usuariocol, " +
            "    DependeKm, " +
            "    mantecion_base, " +
            "    nombre, " +
            "    MantencionUsuariocol, " +
            "    id_usuario, " +
            "    id_mantencion_base, " +
            "    id_vehiculo, " +
            "    DiasEntreMantenciones, " +
            "    URL, " +
            "    beneficios)" +
            "    VALUES" +
            "    (" +
            "    " + (_KmEntreMantenciones != null ? "'" + _KmEntreMantenciones + "'" : "null") + "," +
            "    " + (_descripcion != null ? "'" + _descripcion + "'" : "null") + "," +
            "    " + (_id_mantencion_usuario != null ? "'" + _id_mantencion_usuario + "'" : "null") + "," +
            "    " + (_mantencion_usuariocol != null ? "'" + _mantencion_usuariocol + "'" : "null") + "," +
            "    " + (_DependeKm != null ? "'" + _DependeKm + "'" : "null") + "," +
            "    " + (_mantecion_base != null ? "'" + _mantecion_base + "'" : "null") + "," +
            "    " + (_nombre != null ? "'" + _nombre + "'" : "null") + "," +
            "    " + (_MantencionUsuariocol != null ? "'" + _MantencionUsuariocol + "'" : "null") + "," +
            "    " + (_id_usuario != null ? "'" + _id_usuario + "'" : "null") + "," +
            "    " + (_id_mantencion_base != null ? "'" + _id_mantencion_base + "'" : "null") + "," +
            "    " + (_id_vehiculo != null ? "'" + _id_vehiculo + "'" : "null") + "," +
            "    " + (_DiasEntreMantenciones != null ? "'" + _DiasEntreMantenciones + "'" : "null") + "," +
            "    " + (_URL != null ? "'" + _URL + "'" : "null") + "," +
            "    " + (_beneficios != null ? "'" + _beneficios + "'" : "null") +
            "    )";
        
        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);

        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }

    public int delete(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    DELETE FROM mantencion_usuario" +
            "    WHERE" +
            "    id_usuario = Integer.toString(this._id_usuario)" AND
            "    id_mantencion_usuario = Integer.toString(this._id_mantencion_usuario)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
}

DEBUG [main] (SQLiteORM.java:139) - table: mantencion_usuario_hecha
DEBUG [main] (SQLiteORM.java:150) - columns:
/**
 * 
 */
package bd;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.AbstractMap;
import java.util.ArrayList;

/**
 * @author petete-ntbk
 *
 */
public class Mantencion_usuario_hecha {
private String _fecha;
private Integer _id;
private Integer _id_mantencion_usuario;
private Integer _costo;
private Integer _km;

    private final static String _str_sql = 
        "    SELECT" +
        "    ma.fecha AS fecha," +
        "    ma.id_mantencion_usuario_hecha AS id," +
        "    ma.id_mantencion_usuario AS id_mantencion_usuario," +
        "    ma.costo AS costo," +
        "    ma.km AS km" +
        "    FROM mantencion_usuario_hecha ma";

    public Mantencion_usuario_hecha() {
        _fecha = null;
        _id = null;
        _id_mantencion_usuario = null;
        _costo = null;
        _km = null;

    }
    /**
     * @return the _fecha
     */
    public String get_fecha() {
        return _fecha;
    }
    /**
     * @return the _id
     */
    public Integer get_id() {
        return _id;
    }
    /**
     * @return the _id_mantencion_usuario
     */
    public Integer get_id_mantencion_usuario() {
        return _id_mantencion_usuario;
    }
    /**
     * @return the _costo
     */
    public Integer get_costo() {
        return _costo;
    }
    /**
     * @return the _km
     */
    public Integer get_km() {
        return _km;
    }
    /**
     * @param _fecha the _fecha to set
     */
    public void set_fecha(String _fecha) {
        this._fecha = _fecha;
    }
    /**
     * @param _id the _id to set
     */
    public void set_id(Integer _id) {
        this._id = _id;
    }
    /**
     * @param _id_mantencion_usuario the _id_mantencion_usuario to set
     */
    public void set_id_mantencion_usuario(Integer _id_mantencion_usuario) {
        this._id_mantencion_usuario = _id_mantencion_usuario;
    }
    /**
     * @param _costo the _costo to set
     */
    public void set_costo(Integer _costo) {
        this._costo = _costo;
    }
    /**
     * @param _km the _km to set
     */
    public void set_km(Integer _km) {
        this._km = _km;
    }

    public static Mantencion_usuario_hecha fromRS(ResultSet p_rs) throws SQLException {
        Mantencion_usuario_hecha ret = new Mantencion_usuario_hecha();

        ret.set_fecha(p_rs.getString("fecha"));
        ret.set_id(p_rs.getInt("id"));
        ret.set_id_mantencion_usuario(p_rs.getInt("id_mantencion_usuario"));
        ret.set_costo(p_rs.getInt("costo"));
        ret.set_km(p_rs.getInt("km"));

        return ret;
    }

    public static Mantencion_usuario_hecha getByParameter(Connection p_conn, String p_key, String p_value) throws SQLException {
        Mantencion_usuario_hecha ret = null;
        
        String str_sql = _str_sql +
            "  WHERE ma." + p_key + " = " + p_value +
            "  LIMIT 0, 1";
        
        //System.out.println(str_sql);
        
        // assume that conn is an already created JDBC connection (see previous examples)
        Statement stmt = null;
        ResultSet rs = null;
        
        try {
            stmt = p_conn.createStatement();
            //System.out.println("stmt = p_conn.createStatement() ok");
            rs = stmt.executeQuery(str_sql);
            //System.out.println("rs = stmt.executeQuery(str_sql) ok");

            // Now do something with the ResultSet ....
            
            if (rs.next()) {
                //System.out.println("rs.next() ok");
                ret = fromRS(rs);
                //System.out.println("fromRS(rs) ok");
            }
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        
        
        return ret;        
    }

    public static Mantencion_usuario_hecha getById(Connection p_conn, String p_id) throws Exception {
        return getByParameter(p_conn, "id_mantencion_usuario_hecha", p_id);
    }
    
    public static ArrayList<Mantencion_usuario_hecha> seek(Connection p_conn, ArrayList<AbstractMap.SimpleEntry<String, String>> p_parameters, String p_order, String p_direction, int p_offset, int p_limit) throws Exception {
        Statement stmt = null;
        ResultSet rs = null;
        String str_sql;
        ArrayList<Mantencion_usuario_hecha> ret;
        
        str_sql = "";
        
        try {
            ArrayList<String> array_clauses = new ArrayList<String>();
            
            ret = new ArrayList<Mantencion_usuario_hecha>();
            
            str_sql = _str_sql;
            
            for (AbstractMap.SimpleEntry<String, String> p : p_parameters) {
                if (p.getKey().equals("id_mantencion_usuario_hecha")) {
                    array_clauses.add("ma.id_mantencion_usuario_hecha = " + p.getValue());
                }
                else if (p.getKey().equals("id_mantencion_usuario")) {
                    array_clauses.add("ma.id_mantencion_usuario = " + p.getValue());
                }
                else {
                    throw new Exception("Parametro no soportado: " + p.getKey());
                }
            }
                                
            boolean bFirstTime = false;
            
            for(String clause : array_clauses) {
                if (!bFirstTime) {
                     bFirstTime = true;
                     str_sql += " WHERE ";
                }
                else {
                     str_sql += " AND ";
                }
                str_sql += clause;
            }
            
            if (p_order != null && p_direction != null) {
                str_sql += " ORDER BY " + p_order + " " + p_direction;
            }
            
            if (p_offset != -1 && p_limit != -1) {
                str_sql += "  LIMIT " +  Integer.toString(p_offset) + ", " + Integer.toString(p_limit);
            }
            
            //echo "<br>" . str_sql . "<br>";
        
            stmt = p_conn.createStatement();
            
            rs = stmt.executeQuery(str_sql);
            
            while (rs.next()) {
                ret.add(fromRS(rs));
            }
            /*
            if (ret.size() == 0) {
                ret = null;
            }
            */
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        catch (Exception ex) {
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        

        return ret;
    }

    public int update(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    UPDATE mantencion_usuario_hecha" +
            "    SET" +
            "    fecha = " + (_fecha != null ? "'" + _fecha + "'" : "null") + "," +
            "    costo = " + (_costo != null ? _costo : "null") + "," +
            "    km = " + (_km != null ? _km : "null") +
            "    WHERE" +
            "    id_mantencion_usuario_hecha = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
            /*
            if (stmt.executeUpdate(str_sql) < 1) {
                throw new Exception("No hubo filas afectadas");
            }
            */
            
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
    
    public int insert(Connection p_conn) throws SQLException {
        
        int ret = -1;
        Statement stmt = null;
        ResultSet rs = null;

        String str_sql =
            "    INSERT INTO mantencion_usuario_hecha" +
            "    (" +
            "    fecha, " +
            "    id_mantencion_usuario_hecha, " +
            "    id_mantencion_usuario, " +
            "    costo, " +
            "    km)" +
            "    VALUES" +
            "    (" +
            "    " + (_fecha != null ? "'" + _fecha + "'" : "null") + "," +
            "    " + (_id_mantencion_usuario_hecha != null ? "'" + _id_mantencion_usuario_hecha + "'" : "null") + "," +
            "    " + (_id_mantencion_usuario != null ? "'" + _id_mantencion_usuario + "'" : "null") + "," +
            "    " + (_costo != null ? "'" + _costo + "'" : "null") + "," +
            "    " + (_km != null ? "'" + _km + "'" : "null") +
            "    )";
        
        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);

        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }

    public int delete(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    DELETE FROM mantencion_usuario_hecha" +
            "    WHERE" +
            "    id_mantencion_usuario_hecha = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
}

DEBUG [main] (SQLiteORM.java:139) - table: marca
DEBUG [main] (SQLiteORM.java:150) - columns:
/**
 * 
 */
package bd;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.AbstractMap;
import java.util.ArrayList;

/**
 * @author petete-ntbk
 *
 */
public class Marca {
private String _descripcion;
private String _fecha_modificacion;
private Integer _id;

    private final static String _str_sql = 
        "    SELECT" +
        "    ma.descripcion AS descripcion," +
        "    ma.fecha_modificacion AS fecha_modificacion," +
        "    ma.id_marca AS id" +
        "    FROM marca ma";

    public Marca() {
        _descripcion = null;
        _fecha_modificacion = null;
        _id = null;

    }
    /**
     * @return the _descripcion
     */
    public String get_descripcion() {
        return _descripcion;
    }
    /**
     * @return the _fecha_modificacion
     */
    public String get_fecha_modificacion() {
        return _fecha_modificacion;
    }
    /**
     * @return the _id
     */
    public Integer get_id() {
        return _id;
    }
    /**
     * @param _descripcion the _descripcion to set
     */
    public void set_descripcion(String _descripcion) {
        this._descripcion = _descripcion;
    }
    /**
     * @param _fecha_modificacion the _fecha_modificacion to set
     */
    public void set_fecha_modificacion(String _fecha_modificacion) {
        this._fecha_modificacion = _fecha_modificacion;
    }
    /**
     * @param _id the _id to set
     */
    public void set_id(Integer _id) {
        this._id = _id;
    }

    public static Marca fromRS(ResultSet p_rs) throws SQLException {
        Marca ret = new Marca();

        ret.set_descripcion(p_rs.getString("descripcion"));
        ret.set_fecha_modificacion(p_rs.getString("fecha_modificacion"));
        ret.set_id(p_rs.getInt("id"));

        return ret;
    }

    public static Marca getByParameter(Connection p_conn, String p_key, String p_value) throws SQLException {
        Marca ret = null;
        
        String str_sql = _str_sql +
            "  WHERE ma." + p_key + " = " + p_value +
            "  LIMIT 0, 1";
        
        //System.out.println(str_sql);
        
        // assume that conn is an already created JDBC connection (see previous examples)
        Statement stmt = null;
        ResultSet rs = null;
        
        try {
            stmt = p_conn.createStatement();
            //System.out.println("stmt = p_conn.createStatement() ok");
            rs = stmt.executeQuery(str_sql);
            //System.out.println("rs = stmt.executeQuery(str_sql) ok");

            // Now do something with the ResultSet ....
            
            if (rs.next()) {
                //System.out.println("rs.next() ok");
                ret = fromRS(rs);
                //System.out.println("fromRS(rs) ok");
            }
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        
        
        return ret;        
    }

    public static Marca getById(Connection p_conn, String p_id) throws Exception {
        return getByParameter(p_conn, "id_marca", p_id);
    }
    
    public static ArrayList<Marca> seek(Connection p_conn, ArrayList<AbstractMap.SimpleEntry<String, String>> p_parameters, String p_order, String p_direction, int p_offset, int p_limit) throws Exception {
        Statement stmt = null;
        ResultSet rs = null;
        String str_sql;
        ArrayList<Marca> ret;
        
        str_sql = "";
        
        try {
            ArrayList<String> array_clauses = new ArrayList<String>();
            
            ret = new ArrayList<Marca>();
            
            str_sql = _str_sql;
            
            for (AbstractMap.SimpleEntry<String, String> p : p_parameters) {
                if (p.getKey().equals("id_marca")) {
                    array_clauses.add("ma.id_marca = " + p.getValue());
                }
                else if (p.getKey().equals("mas reciente")) {
                    array_clauses.add("ma.fecha_modificacion > STR_TO_DATE('" + p.getValue() + "', '%d-%m-%Y %H:%i:%s')");
                }
                else {
                    throw new Exception("Parametro no soportado: " + p.getKey());
                }
            }
                                
            boolean bFirstTime = false;
            
            for(String clause : array_clauses) {
                if (!bFirstTime) {
                     bFirstTime = true;
                     str_sql += " WHERE ";
                }
                else {
                     str_sql += " AND ";
                }
                str_sql += clause;
            }
            
            if (p_order != null && p_direction != null) {
                str_sql += " ORDER BY " + p_order + " " + p_direction;
            }
            
            if (p_offset != -1 && p_limit != -1) {
                str_sql += "  LIMIT " +  Integer.toString(p_offset) + ", " + Integer.toString(p_limit);
            }
            
            //echo "<br>" . str_sql . "<br>";
        
            stmt = p_conn.createStatement();
            
            rs = stmt.executeQuery(str_sql);
            
            while (rs.next()) {
                ret.add(fromRS(rs));
            }
            /*
            if (ret.size() == 0) {
                ret = null;
            }
            */
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        catch (Exception ex) {
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        

        return ret;
    }

    public int update(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    UPDATE marca" +
            "    SET" +
            "    descripcion = " + (_descripcion != null ? "'" + _descripcion + "'" : "null") + "," +
            "    fecha_modificacion = " + (_fecha_modificacion != null ? "'" + _fecha_modificacion + "'" : "null") +
            "    WHERE" +
            "    id_marca = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
            /*
            if (stmt.executeUpdate(str_sql) < 1) {
                throw new Exception("No hubo filas afectadas");
            }
            */
            
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
    
    public int insert(Connection p_conn) throws SQLException {
        
        int ret = -1;
        Statement stmt = null;
        ResultSet rs = null;

        String str_sql =
            "    INSERT INTO marca" +
            "    (" +
            "    descripcion, " +
            "    id_marca)" +
            "    VALUES" +
            "    (" +
            "    " + (_descripcion != null ? "'" + _descripcion + "'" : "null") + "," +
            "    " + (_id_marca != null ? "'" + _id_marca + "'" : "null") +
            "    )";
        
        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);

        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }

    public int delete(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    DELETE FROM marca" +
            "    WHERE" +
            "    id_marca = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
}

DEBUG [main] (SQLiteORM.java:139) - table: modelo
DEBUG [main] (SQLiteORM.java:150) - columns:
/**
 * 
 */
package bd;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.AbstractMap;
import java.util.ArrayList;

/**
 * @author petete-ntbk
 *
 */
public class Modelo {
private String _descripcion;
private Integer _id_tipo_vehiculo;
private String _fecha_modificacion;
private Integer _id;
private Integer _id_marca;

    private final static String _str_sql = 
        "    SELECT" +
        "    mo.descripcion AS descripcion," +
        "    mo.id_tipo_vehiculo AS id_tipo_vehiculo," +
        "    mo.fecha_modificacion AS fecha_modificacion," +
        "    mo.id_modelo AS id," +
        "    mo.id_marca AS id_marca" +
        "    FROM modelo mo";

    public Modelo() {
        _descripcion = null;
        _id_tipo_vehiculo = null;
        _fecha_modificacion = null;
        _id = null;
        _id_marca = null;

    }
    /**
     * @return the _descripcion
     */
    public String get_descripcion() {
        return _descripcion;
    }
    /**
     * @return the _id_tipo_vehiculo
     */
    public Integer get_id_tipo_vehiculo() {
        return _id_tipo_vehiculo;
    }
    /**
     * @return the _fecha_modificacion
     */
    public String get_fecha_modificacion() {
        return _fecha_modificacion;
    }
    /**
     * @return the _id
     */
    public Integer get_id() {
        return _id;
    }
    /**
     * @return the _id_marca
     */
    public Integer get_id_marca() {
        return _id_marca;
    }
    /**
     * @param _descripcion the _descripcion to set
     */
    public void set_descripcion(String _descripcion) {
        this._descripcion = _descripcion;
    }
    /**
     * @param _id_tipo_vehiculo the _id_tipo_vehiculo to set
     */
    public void set_id_tipo_vehiculo(Integer _id_tipo_vehiculo) {
        this._id_tipo_vehiculo = _id_tipo_vehiculo;
    }
    /**
     * @param _fecha_modificacion the _fecha_modificacion to set
     */
    public void set_fecha_modificacion(String _fecha_modificacion) {
        this._fecha_modificacion = _fecha_modificacion;
    }
    /**
     * @param _id the _id to set
     */
    public void set_id(Integer _id) {
        this._id = _id;
    }
    /**
     * @param _id_marca the _id_marca to set
     */
    public void set_id_marca(Integer _id_marca) {
        this._id_marca = _id_marca;
    }

    public static Modelo fromRS(ResultSet p_rs) throws SQLException {
        Modelo ret = new Modelo();

        ret.set_descripcion(p_rs.getString("descripcion"));
        ret.set_id_tipo_vehiculo(p_rs.getInt("id_tipo_vehiculo"));
        ret.set_fecha_modificacion(p_rs.getString("fecha_modificacion"));
        ret.set_id(p_rs.getInt("id"));
        ret.set_id_marca(p_rs.getInt("id_marca"));

        return ret;
    }

    public static Modelo getByParameter(Connection p_conn, String p_key, String p_value) throws SQLException {
        Modelo ret = null;
        
        String str_sql = _str_sql +
            "  WHERE mo." + p_key + " = " + p_value +
            "  LIMIT 0, 1";
        
        //System.out.println(str_sql);
        
        // assume that conn is an already created JDBC connection (see previous examples)
        Statement stmt = null;
        ResultSet rs = null;
        
        try {
            stmt = p_conn.createStatement();
            //System.out.println("stmt = p_conn.createStatement() ok");
            rs = stmt.executeQuery(str_sql);
            //System.out.println("rs = stmt.executeQuery(str_sql) ok");

            // Now do something with the ResultSet ....
            
            if (rs.next()) {
                //System.out.println("rs.next() ok");
                ret = fromRS(rs);
                //System.out.println("fromRS(rs) ok");
            }
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        
        
        return ret;        
    }

    public static Modelo getById(Connection p_conn, String p_id) throws Exception {
        return getByParameter(p_conn, "id_modelo", p_id);
    }
    
    public static ArrayList<Modelo> seek(Connection p_conn, ArrayList<AbstractMap.SimpleEntry<String, String>> p_parameters, String p_order, String p_direction, int p_offset, int p_limit) throws Exception {
        Statement stmt = null;
        ResultSet rs = null;
        String str_sql;
        ArrayList<Modelo> ret;
        
        str_sql = "";
        
        try {
            ArrayList<String> array_clauses = new ArrayList<String>();
            
            ret = new ArrayList<Modelo>();
            
            str_sql = _str_sql;
            
            for (AbstractMap.SimpleEntry<String, String> p : p_parameters) {
                if (p.getKey().equals("id_modelo")) {
                    array_clauses.add("mo.id_modelo = " + p.getValue());
                }
                else if (p.getKey().equals("id_tipo_vehiculo")) {
                    array_clauses.add("mo.id_tipo_vehiculo = " + p.getValue());
                }
                else if (p.getKey().equals("id_marca")) {
                    array_clauses.add("mo.id_marca = " + p.getValue());
                }
                else if (p.getKey().equals("mas reciente")) {
                    array_clauses.add("mo.fecha_modificacion > STR_TO_DATE('" + p.getValue() + "', '%d-%m-%Y %H:%i:%s')");
                }
                else {
                    throw new Exception("Parametro no soportado: " + p.getKey());
                }
            }
                                
            boolean bFirstTime = false;
            
            for(String clause : array_clauses) {
                if (!bFirstTime) {
                     bFirstTime = true;
                     str_sql += " WHERE ";
                }
                else {
                     str_sql += " AND ";
                }
                str_sql += clause;
            }
            
            if (p_order != null && p_direction != null) {
                str_sql += " ORDER BY " + p_order + " " + p_direction;
            }
            
            if (p_offset != -1 && p_limit != -1) {
                str_sql += "  LIMIT " +  Integer.toString(p_offset) + ", " + Integer.toString(p_limit);
            }
            
            //echo "<br>" . str_sql . "<br>";
        
            stmt = p_conn.createStatement();
            
            rs = stmt.executeQuery(str_sql);
            
            while (rs.next()) {
                ret.add(fromRS(rs));
            }
            /*
            if (ret.size() == 0) {
                ret = null;
            }
            */
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        catch (Exception ex) {
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        

        return ret;
    }

    public int update(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    UPDATE modelo" +
            "    SET" +
            "    descripcion = " + (_descripcion != null ? "'" + _descripcion + "'" : "null") + "," +
            "    fecha_modificacion = " + (_fecha_modificacion != null ? "'" + _fecha_modificacion + "'" : "null") +
            "    WHERE" +
            "    id_modelo = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
            /*
            if (stmt.executeUpdate(str_sql) < 1) {
                throw new Exception("No hubo filas afectadas");
            }
            */
            
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
    
    public int insert(Connection p_conn) throws SQLException {
        
        int ret = -1;
        Statement stmt = null;
        ResultSet rs = null;

        String str_sql =
            "    INSERT INTO modelo" +
            "    (" +
            "    descripcion, " +
            "    id_tipo_vehiculo, " +
            "    id_modelo, " +
            "    id_marca)" +
            "    VALUES" +
            "    (" +
            "    " + (_descripcion != null ? "'" + _descripcion + "'" : "null") + "," +
            "    " + (_id_tipo_vehiculo != null ? "'" + _id_tipo_vehiculo + "'" : "null") + "," +
            "    " + (_id_modelo != null ? "'" + _id_modelo + "'" : "null") + "," +
            "    " + (_id_marca != null ? "'" + _id_marca + "'" : "null") +
            "    )";
        
        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);

        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }

    public int delete(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    DELETE FROM modelo" +
            "    WHERE" +
            "    id_modelo = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
}

DEBUG [main] (SQLiteORM.java:139) - table: modelo_anio
DEBUG [main] (SQLiteORM.java:150) - columns:
/**
 * 
 */
package bd;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.AbstractMap;
import java.util.ArrayList;

/**
 * @author petete-ntbk
 *
 */
public class Modelo_anio {
private Integer _anio;
private Integer _id;
private Integer _id_modelo;

    private final static String _str_sql = 
        "    SELECT" +
        "    mo.anio AS anio," +
        "    mo.id_modelo_anio AS id," +
        "    mo.id_modelo AS id_modelo" +
        "    FROM modelo_anio mo";

    public Modelo_anio() {
        _anio = null;
        _id = null;
        _id_modelo = null;

    }
    /**
     * @return the _anio
     */
    public Integer get_anio() {
        return _anio;
    }
    /**
     * @return the _id
     */
    public Integer get_id() {
        return _id;
    }
    /**
     * @return the _id_modelo
     */
    public Integer get_id_modelo() {
        return _id_modelo;
    }
    /**
     * @param _anio the _anio to set
     */
    public void set_anio(Integer _anio) {
        this._anio = _anio;
    }
    /**
     * @param _id the _id to set
     */
    public void set_id(Integer _id) {
        this._id = _id;
    }
    /**
     * @param _id_modelo the _id_modelo to set
     */
    public void set_id_modelo(Integer _id_modelo) {
        this._id_modelo = _id_modelo;
    }

    public static Modelo_anio fromRS(ResultSet p_rs) throws SQLException {
        Modelo_anio ret = new Modelo_anio();

        ret.set_anio(p_rs.getInt("anio"));
        ret.set_id(p_rs.getInt("id"));
        ret.set_id_modelo(p_rs.getInt("id_modelo"));

        return ret;
    }

    public static Modelo_anio getByParameter(Connection p_conn, String p_key, String p_value) throws SQLException {
        Modelo_anio ret = null;
        
        String str_sql = _str_sql +
            "  WHERE mo." + p_key + " = " + p_value +
            "  LIMIT 0, 1";
        
        //System.out.println(str_sql);
        
        // assume that conn is an already created JDBC connection (see previous examples)
        Statement stmt = null;
        ResultSet rs = null;
        
        try {
            stmt = p_conn.createStatement();
            //System.out.println("stmt = p_conn.createStatement() ok");
            rs = stmt.executeQuery(str_sql);
            //System.out.println("rs = stmt.executeQuery(str_sql) ok");

            // Now do something with the ResultSet ....
            
            if (rs.next()) {
                //System.out.println("rs.next() ok");
                ret = fromRS(rs);
                //System.out.println("fromRS(rs) ok");
            }
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        
        
        return ret;        
    }

    public static Modelo_anio getById(Connection p_conn, String p_id) throws Exception {
        return getByParameter(p_conn, "id_modelo_anio", p_id);
    }
    
    public static ArrayList<Modelo_anio> seek(Connection p_conn, ArrayList<AbstractMap.SimpleEntry<String, String>> p_parameters, String p_order, String p_direction, int p_offset, int p_limit) throws Exception {
        Statement stmt = null;
        ResultSet rs = null;
        String str_sql;
        ArrayList<Modelo_anio> ret;
        
        str_sql = "";
        
        try {
            ArrayList<String> array_clauses = new ArrayList<String>();
            
            ret = new ArrayList<Modelo_anio>();
            
            str_sql = _str_sql;
            
            for (AbstractMap.SimpleEntry<String, String> p : p_parameters) {
                if (p.getKey().equals("id_modelo_anio")) {
                    array_clauses.add("mo.id_modelo_anio = " + p.getValue());
                }
                else if (p.getKey().equals("id_modelo")) {
                    array_clauses.add("mo.id_modelo = " + p.getValue());
                }
                else {
                    throw new Exception("Parametro no soportado: " + p.getKey());
                }
            }
                                
            boolean bFirstTime = false;
            
            for(String clause : array_clauses) {
                if (!bFirstTime) {
                     bFirstTime = true;
                     str_sql += " WHERE ";
                }
                else {
                     str_sql += " AND ";
                }
                str_sql += clause;
            }
            
            if (p_order != null && p_direction != null) {
                str_sql += " ORDER BY " + p_order + " " + p_direction;
            }
            
            if (p_offset != -1 && p_limit != -1) {
                str_sql += "  LIMIT " +  Integer.toString(p_offset) + ", " + Integer.toString(p_limit);
            }
            
            //echo "<br>" . str_sql . "<br>";
        
            stmt = p_conn.createStatement();
            
            rs = stmt.executeQuery(str_sql);
            
            while (rs.next()) {
                ret.add(fromRS(rs));
            }
            /*
            if (ret.size() == 0) {
                ret = null;
            }
            */
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        catch (Exception ex) {
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        

        return ret;
    }

    public int update(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    UPDATE modelo_anio" +
            "    SET" +
            "    anio = " + (_anio != null ? _anio : "null") +
            "    WHERE" +
            "    id_modelo_anio = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
            /*
            if (stmt.executeUpdate(str_sql) < 1) {
                throw new Exception("No hubo filas afectadas");
            }
            */
            
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
    
    public int insert(Connection p_conn) throws SQLException {
        
        int ret = -1;
        Statement stmt = null;
        ResultSet rs = null;

        String str_sql =
            "    INSERT INTO modelo_anio" +
            "    (" +
            "    anio, " +
            "    id_modelo_anio, " +
            "    id_modelo)" +
            "    VALUES" +
            "    (" +
            "    " + (_anio != null ? "'" + _anio + "'" : "null") + "," +
            "    " + (_id_modelo_anio != null ? "'" + _id_modelo_anio + "'" : "null") + "," +
            "    " + (_id_modelo != null ? "'" + _id_modelo + "'" : "null") +
            "    )";
        
        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);

        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }

    public int delete(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    DELETE FROM modelo_anio" +
            "    WHERE" +
            "    id_modelo_anio = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
}

DEBUG [main] (SQLiteORM.java:139) - table: motor
DEBUG [main] (SQLiteORM.java:150) - columns:
/**
 * 
 */
package bd;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.AbstractMap;
import java.util.ArrayList;

/**
 * @author petete-ntbk
 *
 */
public class Motor {
private String _configuracion;
private Integer _valvulas;
private Integer _torque;
private Integer _cilindros;
private String _razon_compresion;
private String _codigo_fabricante;
private String _codigo;
private Integer _desplazamiento;
private Integer _id_modelo_anio;
private String _tamanio;
private String _tipo;
private Integer _id;
private Integer _potencia;
private String _tipo_compresor;
private String _tipo_combustible;

    private final static String _str_sql = 
        "    SELECT" +
        "    mo.configuracion AS configuracion," +
        "    mo.valvulas AS valvulas," +
        "    mo.torque AS torque," +
        "    mo.cilindros AS cilindros," +
        "    mo.razon_compresion AS razon_compresion," +
        "    mo.codigo_fabricante AS codigo_fabricante," +
        "    mo.codigo AS codigo," +
        "    mo.desplazamiento AS desplazamiento," +
        "    mo.id_modelo_anio AS id_modelo_anio," +
        "    mo.tamanio AS tamanio," +
        "    mo.tipo AS tipo," +
        "    mo.id_motor AS id," +
        "    mo.potencia AS potencia," +
        "    mo.tipo_compresor AS tipo_compresor," +
        "    mo.tipo_combustible AS tipo_combustible" +
        "    FROM motor mo";

    public Motor() {
        _configuracion = null;
        _valvulas = null;
        _torque = null;
        _cilindros = null;
        _razon_compresion = null;
        _codigo_fabricante = null;
        _codigo = null;
        _desplazamiento = null;
        _id_modelo_anio = null;
        _tamanio = null;
        _tipo = null;
        _id = null;
        _potencia = null;
        _tipo_compresor = null;
        _tipo_combustible = null;

    }
    /**
     * @return the _configuracion
     */
    public String get_configuracion() {
        return _configuracion;
    }
    /**
     * @return the _valvulas
     */
    public Integer get_valvulas() {
        return _valvulas;
    }
    /**
     * @return the _torque
     */
    public Integer get_torque() {
        return _torque;
    }
    /**
     * @return the _cilindros
     */
    public Integer get_cilindros() {
        return _cilindros;
    }
    /**
     * @return the _razon_compresion
     */
    public String get_razon_compresion() {
        return _razon_compresion;
    }
    /**
     * @return the _codigo_fabricante
     */
    public String get_codigo_fabricante() {
        return _codigo_fabricante;
    }
    /**
     * @return the _codigo
     */
    public String get_codigo() {
        return _codigo;
    }
    /**
     * @return the _desplazamiento
     */
    public Integer get_desplazamiento() {
        return _desplazamiento;
    }
    /**
     * @return the _id_modelo_anio
     */
    public Integer get_id_modelo_anio() {
        return _id_modelo_anio;
    }
    /**
     * @return the _tamanio
     */
    public String get_tamanio() {
        return _tamanio;
    }
    /**
     * @return the _tipo
     */
    public String get_tipo() {
        return _tipo;
    }
    /**
     * @return the _id
     */
    public Integer get_id() {
        return _id;
    }
    /**
     * @return the _potencia
     */
    public Integer get_potencia() {
        return _potencia;
    }
    /**
     * @return the _tipo_compresor
     */
    public String get_tipo_compresor() {
        return _tipo_compresor;
    }
    /**
     * @return the _tipo_combustible
     */
    public String get_tipo_combustible() {
        return _tipo_combustible;
    }
    /**
     * @param _configuracion the _configuracion to set
     */
    public void set_configuracion(String _configuracion) {
        this._configuracion = _configuracion;
    }
    /**
     * @param _valvulas the _valvulas to set
     */
    public void set_valvulas(Integer _valvulas) {
        this._valvulas = _valvulas;
    }
    /**
     * @param _torque the _torque to set
     */
    public void set_torque(Integer _torque) {
        this._torque = _torque;
    }
    /**
     * @param _cilindros the _cilindros to set
     */
    public void set_cilindros(Integer _cilindros) {
        this._cilindros = _cilindros;
    }
    /**
     * @param _razon_compresion the _razon_compresion to set
     */
    public void set_razon_compresion(String _razon_compresion) {
        this._razon_compresion = _razon_compresion;
    }
    /**
     * @param _codigo_fabricante the _codigo_fabricante to set
     */
    public void set_codigo_fabricante(String _codigo_fabricante) {
        this._codigo_fabricante = _codigo_fabricante;
    }
    /**
     * @param _codigo the _codigo to set
     */
    public void set_codigo(String _codigo) {
        this._codigo = _codigo;
    }
    /**
     * @param _desplazamiento the _desplazamiento to set
     */
    public void set_desplazamiento(Integer _desplazamiento) {
        this._desplazamiento = _desplazamiento;
    }
    /**
     * @param _id_modelo_anio the _id_modelo_anio to set
     */
    public void set_id_modelo_anio(Integer _id_modelo_anio) {
        this._id_modelo_anio = _id_modelo_anio;
    }
    /**
     * @param _tamanio the _tamanio to set
     */
    public void set_tamanio(String _tamanio) {
        this._tamanio = _tamanio;
    }
    /**
     * @param _tipo the _tipo to set
     */
    public void set_tipo(String _tipo) {
        this._tipo = _tipo;
    }
    /**
     * @param _id the _id to set
     */
    public void set_id(Integer _id) {
        this._id = _id;
    }
    /**
     * @param _potencia the _potencia to set
     */
    public void set_potencia(Integer _potencia) {
        this._potencia = _potencia;
    }
    /**
     * @param _tipo_compresor the _tipo_compresor to set
     */
    public void set_tipo_compresor(String _tipo_compresor) {
        this._tipo_compresor = _tipo_compresor;
    }
    /**
     * @param _tipo_combustible the _tipo_combustible to set
     */
    public void set_tipo_combustible(String _tipo_combustible) {
        this._tipo_combustible = _tipo_combustible;
    }

    public static Motor fromRS(ResultSet p_rs) throws SQLException {
        Motor ret = new Motor();

        ret.set_configuracion(p_rs.getString("configuracion"));
        ret.set_valvulas(p_rs.getInt("valvulas"));
        ret.set_torque(p_rs.getInt("torque"));
        ret.set_cilindros(p_rs.getInt("cilindros"));
        ret.set_razon_compresion(p_rs.getString("razon_compresion"));
        ret.set_codigo_fabricante(p_rs.getString("codigo_fabricante"));
        ret.set_codigo(p_rs.getString("codigo"));
        ret.set_desplazamiento(p_rs.getInt("desplazamiento"));
        ret.set_id_modelo_anio(p_rs.getInt("id_modelo_anio"));
        ret.set_tamanio(p_rs.getString("tamanio"));
        ret.set_tipo(p_rs.getString("tipo"));
        ret.set_id(p_rs.getInt("id"));
        ret.set_potencia(p_rs.getInt("potencia"));
        ret.set_tipo_compresor(p_rs.getString("tipo_compresor"));
        ret.set_tipo_combustible(p_rs.getString("tipo_combustible"));

        return ret;
    }

    public static Motor getByParameter(Connection p_conn, String p_key, String p_value) throws SQLException {
        Motor ret = null;
        
        String str_sql = _str_sql +
            "  WHERE mo." + p_key + " = " + p_value +
            "  LIMIT 0, 1";
        
        //System.out.println(str_sql);
        
        // assume that conn is an already created JDBC connection (see previous examples)
        Statement stmt = null;
        ResultSet rs = null;
        
        try {
            stmt = p_conn.createStatement();
            //System.out.println("stmt = p_conn.createStatement() ok");
            rs = stmt.executeQuery(str_sql);
            //System.out.println("rs = stmt.executeQuery(str_sql) ok");

            // Now do something with the ResultSet ....
            
            if (rs.next()) {
                //System.out.println("rs.next() ok");
                ret = fromRS(rs);
                //System.out.println("fromRS(rs) ok");
            }
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        
        
        return ret;        
    }

    public static Motor getById(Connection p_conn, String p_id) throws Exception {
        return getByParameter(p_conn, "id_motor", p_id);
    }
    
    public static ArrayList<Motor> seek(Connection p_conn, ArrayList<AbstractMap.SimpleEntry<String, String>> p_parameters, String p_order, String p_direction, int p_offset, int p_limit) throws Exception {
        Statement stmt = null;
        ResultSet rs = null;
        String str_sql;
        ArrayList<Motor> ret;
        
        str_sql = "";
        
        try {
            ArrayList<String> array_clauses = new ArrayList<String>();
            
            ret = new ArrayList<Motor>();
            
            str_sql = _str_sql;
            
            for (AbstractMap.SimpleEntry<String, String> p : p_parameters) {
                if (p.getKey().equals("id_motor")) {
                    array_clauses.add("mo.id_motor = " + p.getValue());
                }
                else if (p.getKey().equals("id_modelo_anio")) {
                    array_clauses.add("mo.id_modelo_anio = " + p.getValue());
                }
                else {
                    throw new Exception("Parametro no soportado: " + p.getKey());
                }
            }
                                
            boolean bFirstTime = false;
            
            for(String clause : array_clauses) {
                if (!bFirstTime) {
                     bFirstTime = true;
                     str_sql += " WHERE ";
                }
                else {
                     str_sql += " AND ";
                }
                str_sql += clause;
            }
            
            if (p_order != null && p_direction != null) {
                str_sql += " ORDER BY " + p_order + " " + p_direction;
            }
            
            if (p_offset != -1 && p_limit != -1) {
                str_sql += "  LIMIT " +  Integer.toString(p_offset) + ", " + Integer.toString(p_limit);
            }
            
            //echo "<br>" . str_sql . "<br>";
        
            stmt = p_conn.createStatement();
            
            rs = stmt.executeQuery(str_sql);
            
            while (rs.next()) {
                ret.add(fromRS(rs));
            }
            /*
            if (ret.size() == 0) {
                ret = null;
            }
            */
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        catch (Exception ex) {
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        

        return ret;
    }

    public int update(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    UPDATE motor" +
            "    SET" +
            "    configuracion = " + (_configuracion != null ? "'" + _configuracion + "'" : "null") + "," +
            "    valvulas = " + (_valvulas != null ? _valvulas : "null") + "," +
            "    torque = " + (_torque != null ? _torque : "null") + "," +
            "    cilindros = " + (_cilindros != null ? _cilindros : "null") + "," +
            "    razon_compresion = " + (_razon_compresion != null ? "'" + _razon_compresion + "'" : "null") + "," +
            "    codigo_fabricante = " + (_codigo_fabricante != null ? "'" + _codigo_fabricante + "'" : "null") + "," +
            "    codigo = " + (_codigo != null ? "'" + _codigo + "'" : "null") + "," +
            "    desplazamiento = " + (_desplazamiento != null ? _desplazamiento : "null") + "," +
            "    tamanio = " + (_tamanio != null ? "'" + _tamanio + "'" : "null") + "," +
            "    tipo = " + (_tipo != null ? "'" + _tipo + "'" : "null") + "," +
            "    potencia = " + (_potencia != null ? _potencia : "null") + "," +
            "    tipo_compresor = " + (_tipo_compresor != null ? "'" + _tipo_compresor + "'" : "null") + "," +
            "    tipo_combustible = " + (_tipo_combustible != null ? "'" + _tipo_combustible + "'" : "null") +
            "    WHERE" +
            "    id_motor = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
            /*
            if (stmt.executeUpdate(str_sql) < 1) {
                throw new Exception("No hubo filas afectadas");
            }
            */
            
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
    
    public int insert(Connection p_conn) throws SQLException {
        
        int ret = -1;
        Statement stmt = null;
        ResultSet rs = null;

        String str_sql =
            "    INSERT INTO motor" +
            "    (" +
            "    configuracion, " +
            "    valvulas, " +
            "    torque, " +
            "    cilindros, " +
            "    razon_compresion, " +
            "    codigo_fabricante, " +
            "    codigo, " +
            "    desplazamiento, " +
            "    id_modelo_anio, " +
            "    tamanio, " +
            "    tipo, " +
            "    id_motor, " +
            "    potencia, " +
            "    tipo_compresor, " +
            "    tipo_combustible)" +
            "    VALUES" +
            "    (" +
            "    " + (_configuracion != null ? "'" + _configuracion + "'" : "null") + "," +
            "    " + (_valvulas != null ? "'" + _valvulas + "'" : "null") + "," +
            "    " + (_torque != null ? "'" + _torque + "'" : "null") + "," +
            "    " + (_cilindros != null ? "'" + _cilindros + "'" : "null") + "," +
            "    " + (_razon_compresion != null ? "'" + _razon_compresion + "'" : "null") + "," +
            "    " + (_codigo_fabricante != null ? "'" + _codigo_fabricante + "'" : "null") + "," +
            "    " + (_codigo != null ? "'" + _codigo + "'" : "null") + "," +
            "    " + (_desplazamiento != null ? "'" + _desplazamiento + "'" : "null") + "," +
            "    " + (_id_modelo_anio != null ? "'" + _id_modelo_anio + "'" : "null") + "," +
            "    " + (_tamanio != null ? "'" + _tamanio + "'" : "null") + "," +
            "    " + (_tipo != null ? "'" + _tipo + "'" : "null") + "," +
            "    " + (_id_motor != null ? "'" + _id_motor + "'" : "null") + "," +
            "    " + (_potencia != null ? "'" + _potencia + "'" : "null") + "," +
            "    " + (_tipo_compresor != null ? "'" + _tipo_compresor + "'" : "null") + "," +
            "    " + (_tipo_combustible != null ? "'" + _tipo_combustible + "'" : "null") +
            "    )";
        
        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);

        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }

    public int delete(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    DELETE FROM motor" +
            "    WHERE" +
            "    id_motor = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
}

DEBUG [main] (SQLiteORM.java:139) - table: pais
DEBUG [main] (SQLiteORM.java:150) - columns:
/**
 * 
 */
package bd;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.AbstractMap;
import java.util.ArrayList;

/**
 * @author petete-ntbk
 *
 */
public class Pais {
private String _pais;
private Integer _id;

    private final static String _str_sql = 
        "    SELECT" +
        "    pa.pais AS pais," +
        "    pa.id_pais AS id" +
        "    FROM pais pa";

    public Pais() {
        _pais = null;
        _id = null;

    }
    /**
     * @return the _pais
     */
    public String get_pais() {
        return _pais;
    }
    /**
     * @return the _id
     */
    public Integer get_id() {
        return _id;
    }
    /**
     * @param _pais the _pais to set
     */
    public void set_pais(String _pais) {
        this._pais = _pais;
    }
    /**
     * @param _id the _id to set
     */
    public void set_id(Integer _id) {
        this._id = _id;
    }

    public static Pais fromRS(ResultSet p_rs) throws SQLException {
        Pais ret = new Pais();

        ret.set_pais(p_rs.getString("pais"));
        ret.set_id(p_rs.getInt("id"));

        return ret;
    }

    public static Pais getByParameter(Connection p_conn, String p_key, String p_value) throws SQLException {
        Pais ret = null;
        
        String str_sql = _str_sql +
            "  WHERE pa." + p_key + " = " + p_value +
            "  LIMIT 0, 1";
        
        //System.out.println(str_sql);
        
        // assume that conn is an already created JDBC connection (see previous examples)
        Statement stmt = null;
        ResultSet rs = null;
        
        try {
            stmt = p_conn.createStatement();
            //System.out.println("stmt = p_conn.createStatement() ok");
            rs = stmt.executeQuery(str_sql);
            //System.out.println("rs = stmt.executeQuery(str_sql) ok");

            // Now do something with the ResultSet ....
            
            if (rs.next()) {
                //System.out.println("rs.next() ok");
                ret = fromRS(rs);
                //System.out.println("fromRS(rs) ok");
            }
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        
        
        return ret;        
    }

    public static Pais getById(Connection p_conn, String p_id) throws Exception {
        return getByParameter(p_conn, "id_pais", p_id);
    }
    
    public static ArrayList<Pais> seek(Connection p_conn, ArrayList<AbstractMap.SimpleEntry<String, String>> p_parameters, String p_order, String p_direction, int p_offset, int p_limit) throws Exception {
        Statement stmt = null;
        ResultSet rs = null;
        String str_sql;
        ArrayList<Pais> ret;
        
        str_sql = "";
        
        try {
            ArrayList<String> array_clauses = new ArrayList<String>();
            
            ret = new ArrayList<Pais>();
            
            str_sql = _str_sql;
            
            for (AbstractMap.SimpleEntry<String, String> p : p_parameters) {
                if (p.getKey().equals("id_pais")) {
                    array_clauses.add("pa.id_pais = " + p.getValue());
                }
                else {
                    throw new Exception("Parametro no soportado: " + p.getKey());
                }
            }
                                
            boolean bFirstTime = false;
            
            for(String clause : array_clauses) {
                if (!bFirstTime) {
                     bFirstTime = true;
                     str_sql += " WHERE ";
                }
                else {
                     str_sql += " AND ";
                }
                str_sql += clause;
            }
            
            if (p_order != null && p_direction != null) {
                str_sql += " ORDER BY " + p_order + " " + p_direction;
            }
            
            if (p_offset != -1 && p_limit != -1) {
                str_sql += "  LIMIT " +  Integer.toString(p_offset) + ", " + Integer.toString(p_limit);
            }
            
            //echo "<br>" . str_sql . "<br>";
        
            stmt = p_conn.createStatement();
            
            rs = stmt.executeQuery(str_sql);
            
            while (rs.next()) {
                ret.add(fromRS(rs));
            }
            /*
            if (ret.size() == 0) {
                ret = null;
            }
            */
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        catch (Exception ex) {
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        

        return ret;
    }

    public int update(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    UPDATE pais" +
            "    SET" +
            "    pais = " + (_pais != null ? "'" + _pais + "'" : "null") +
            "    WHERE" +
            "    id_pais = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
            /*
            if (stmt.executeUpdate(str_sql) < 1) {
                throw new Exception("No hubo filas afectadas");
            }
            */
            
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
    
    public int insert(Connection p_conn) throws SQLException {
        
        int ret = -1;
        Statement stmt = null;
        ResultSet rs = null;

        String str_sql =
            "    INSERT INTO pais" +
            "    (" +
            "    pais, " +
            "    id_pais)" +
            "    VALUES" +
            "    (" +
            "    " + (_pais != null ? "'" + _pais + "'" : "null") + "," +
            "    " + (_id_pais != null ? "'" + _id_pais + "'" : "null") +
            "    )";
        
        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);

        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }

    public int delete(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    DELETE FROM pais" +
            "    WHERE" +
            "    id_pais = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
}

DEBUG [main] (SQLiteORM.java:139) - table: recordatorio
DEBUG [main] (SQLiteORM.java:150) - columns:
/**
 * 
 */
package bd;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.AbstractMap;
import java.util.ArrayList;

/**
 * @author petete-ntbk
 *
 */
public class Recordatorio {
private String _fecha;
private String _descripcion;
private String _recordar_km;
private Integer _km;
private String _recordar_fecha;
private String _descartado;
private Integer _id_recordatorio;
private String _titulo;
private String _fecha_modificacion;
private Integer _id_usuario;
private Integer _id_vehiculo;
private String _recordatoriocol;

    private final static String _str_sql = 
        "    SELECT" +
        "    re.fecha AS fecha," +
        "    re.descripcion AS descripcion," +
        "    re.recordar_km AS recordar_km," +
        "    re.km AS km," +
        "    re.recordar_fecha AS recordar_fecha," +
        "    re.descartado AS descartado," +
        "    re.id_recordatorio AS id_recordatorio," +
        "    re.titulo AS titulo," +
        "    re.fecha_modificacion AS fecha_modificacion," +
        "    re.id_usuario AS id_usuario," +
        "    re.id_vehiculo AS id_vehiculo," +
        "    re.recordatoriocol AS recordatoriocol" +
        "    FROM recordatorio re";

    public Recordatorio() {
        _fecha = null;
        _descripcion = null;
        _recordar_km = null;
        _km = null;
        _recordar_fecha = null;
        _descartado = null;
        _id_recordatorio = null;
        _titulo = null;
        _fecha_modificacion = null;
        _id_usuario = null;
        _id_vehiculo = null;
        _recordatoriocol = null;

    }
    /**
     * @return the _fecha
     */
    public String get_fecha() {
        return _fecha;
    }
    /**
     * @return the _descripcion
     */
    public String get_descripcion() {
        return _descripcion;
    }
    /**
     * @return the _recordar_km
     */
    public String get_recordar_km() {
        return _recordar_km;
    }
    /**
     * @return the _km
     */
    public Integer get_km() {
        return _km;
    }
    /**
     * @return the _recordar_fecha
     */
    public String get_recordar_fecha() {
        return _recordar_fecha;
    }
    /**
     * @return the _descartado
     */
    public String get_descartado() {
        return _descartado;
    }
    /**
     * @return the _id_recordatorio
     */
    public Integer get_id_recordatorio() {
        return _id_recordatorio;
    }
    /**
     * @return the _titulo
     */
    public String get_titulo() {
        return _titulo;
    }
    /**
     * @return the _fecha_modificacion
     */
    public String get_fecha_modificacion() {
        return _fecha_modificacion;
    }
    /**
     * @return the _id_usuario
     */
    public Integer get_id_usuario() {
        return _id_usuario;
    }
    /**
     * @return the _id_vehiculo
     */
    public Integer get_id_vehiculo() {
        return _id_vehiculo;
    }
    /**
     * @return the _recordatoriocol
     */
    public String get_recordatoriocol() {
        return _recordatoriocol;
    }
    /**
     * @param _fecha the _fecha to set
     */
    public void set_fecha(String _fecha) {
        this._fecha = _fecha;
    }
    /**
     * @param _descripcion the _descripcion to set
     */
    public void set_descripcion(String _descripcion) {
        this._descripcion = _descripcion;
    }
    /**
     * @param _recordar_km the _recordar_km to set
     */
    public void set_recordar_km(String _recordar_km) {
        this._recordar_km = _recordar_km;
    }
    /**
     * @param _km the _km to set
     */
    public void set_km(Integer _km) {
        this._km = _km;
    }
    /**
     * @param _recordar_fecha the _recordar_fecha to set
     */
    public void set_recordar_fecha(String _recordar_fecha) {
        this._recordar_fecha = _recordar_fecha;
    }
    /**
     * @param _descartado the _descartado to set
     */
    public void set_descartado(String _descartado) {
        this._descartado = _descartado;
    }
    /**
     * @param _id_recordatorio the _id_recordatorio to set
     */
    public void set_id_recordatorio(Integer _id_recordatorio) {
        this._id_recordatorio = _id_recordatorio;
    }
    /**
     * @param _titulo the _titulo to set
     */
    public void set_titulo(String _titulo) {
        this._titulo = _titulo;
    }
    /**
     * @param _fecha_modificacion the _fecha_modificacion to set
     */
    public void set_fecha_modificacion(String _fecha_modificacion) {
        this._fecha_modificacion = _fecha_modificacion;
    }
    /**
     * @param _id_usuario the _id_usuario to set
     */
    public void set_id_usuario(Integer _id_usuario) {
        this._id_usuario = _id_usuario;
    }
    /**
     * @param _id_vehiculo the _id_vehiculo to set
     */
    public void set_id_vehiculo(Integer _id_vehiculo) {
        this._id_vehiculo = _id_vehiculo;
    }
    /**
     * @param _recordatoriocol the _recordatoriocol to set
     */
    public void set_recordatoriocol(String _recordatoriocol) {
        this._recordatoriocol = _recordatoriocol;
    }

    public static Recordatorio fromRS(ResultSet p_rs) throws SQLException {
        Recordatorio ret = new Recordatorio();

        ret.set_fecha(p_rs.getString("fecha"));
        ret.set_descripcion(p_rs.getString("descripcion"));
        ret.set_recordar_km(p_rs.getString("recordar_km"));
        ret.set_km(p_rs.getInt("km"));
        ret.set_recordar_fecha(p_rs.getString("recordar_fecha"));
        ret.set_descartado(p_rs.getString("descartado"));
        ret.set_id_recordatorio(p_rs.getInt("id_recordatorio"));
        ret.set_titulo(p_rs.getString("titulo"));
        ret.set_fecha_modificacion(p_rs.getString("fecha_modificacion"));
        ret.set_id_usuario(p_rs.getInt("id_usuario"));
        ret.set_id_vehiculo(p_rs.getInt("id_vehiculo"));
        ret.set_recordatoriocol(p_rs.getString("recordatoriocol"));

        return ret;
    }

    public static Recordatorio getByParameter(Connection p_conn, String p_key, String p_value) throws SQLException {
        Recordatorio ret = null;
        
        String str_sql = _str_sql +
            "  WHERE re." + p_key + " = " + p_value +
            "  LIMIT 0, 1";
        
        //System.out.println(str_sql);
        
        // assume that conn is an already created JDBC connection (see previous examples)
        Statement stmt = null;
        ResultSet rs = null;
        
        try {
            stmt = p_conn.createStatement();
            //System.out.println("stmt = p_conn.createStatement() ok");
            rs = stmt.executeQuery(str_sql);
            //System.out.println("rs = stmt.executeQuery(str_sql) ok");

            // Now do something with the ResultSet ....
            
            if (rs.next()) {
                //System.out.println("rs.next() ok");
                ret = fromRS(rs);
                //System.out.println("fromRS(rs) ok");
            }
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        
        
        return ret;        
    }

    
    public static ArrayList<Recordatorio> seek(Connection p_conn, ArrayList<AbstractMap.SimpleEntry<String, String>> p_parameters, String p_order, String p_direction, int p_offset, int p_limit) throws Exception {
        Statement stmt = null;
        ResultSet rs = null;
        String str_sql;
        ArrayList<Recordatorio> ret;
        
        str_sql = "";
        
        try {
            ArrayList<String> array_clauses = new ArrayList<String>();
            
            ret = new ArrayList<Recordatorio>();
            
            str_sql = _str_sql;
            
            for (AbstractMap.SimpleEntry<String, String> p : p_parameters) {
                if (p.getKey().equals("id_recordatorio")) {
                    array_clauses.add("re.id_recordatorio = " + p.getValue());
                }
                else if (p.getKey().equals("id_usuario")) {
                    array_clauses.add("re.id_usuario = " + p.getValue());
                }
                else if (p.getKey().equals("id_usuario")) {
                    array_clauses.add("re.id_usuario = " + p.getValue());
                }
                else if (p.getKey().equals("id_vehiculo")) {
                    array_clauses.add("re.id_vehiculo = " + p.getValue());
                }
                else if (p.getKey().equals("mas reciente")) {
                    array_clauses.add("re.fecha_modificacion > STR_TO_DATE('" + p.getValue() + "', '%d-%m-%Y %H:%i:%s')");
                }
                else {
                    throw new Exception("Parametro no soportado: " + p.getKey());
                }
            }
                                
            boolean bFirstTime = false;
            
            for(String clause : array_clauses) {
                if (!bFirstTime) {
                     bFirstTime = true;
                     str_sql += " WHERE ";
                }
                else {
                     str_sql += " AND ";
                }
                str_sql += clause;
            }
            
            if (p_order != null && p_direction != null) {
                str_sql += " ORDER BY " + p_order + " " + p_direction;
            }
            
            if (p_offset != -1 && p_limit != -1) {
                str_sql += "  LIMIT " +  Integer.toString(p_offset) + ", " + Integer.toString(p_limit);
            }
            
            //echo "<br>" . str_sql . "<br>";
        
            stmt = p_conn.createStatement();
            
            rs = stmt.executeQuery(str_sql);
            
            while (rs.next()) {
                ret.add(fromRS(rs));
            }
            /*
            if (ret.size() == 0) {
                ret = null;
            }
            */
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        catch (Exception ex) {
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        

        return ret;
    }

    public int update(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    UPDATE recordatorio" +
            "    SET" +
            "    fecha = " + (_fecha != null ? "'" + _fecha + "'" : "null") + "," +
            "    descripcion = " + (_descripcion != null ? "'" + _descripcion + "'" : "null") + "," +
            "    recordar_km = " + (_recordar_km != null ? "'" + _recordar_km + "'" : "null") + "," +
            "    km = " + (_km != null ? _km : "null") + "," +
            "    recordar_fecha = " + (_recordar_fecha != null ? "'" + _recordar_fecha + "'" : "null") + "," +
            "    descartado = " + (_descartado != null ? "'" + _descartado + "'" : "null") + "," +
            "    titulo = " + (_titulo != null ? "'" + _titulo + "'" : "null") + "," +
            "    fecha_modificacion = " + (_fecha_modificacion != null ? "'" + _fecha_modificacion + "'" : "null") + "," +
            "    recordatoriocol = " + (_recordatoriocol != null ? "'" + _recordatoriocol + "'" : "null") +
            "    WHERE" +
            "    id_recordatorio = Integer.toString(this._id_recordatorio)" AND
            "    id_usuario = Integer.toString(this._id_usuario)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
            /*
            if (stmt.executeUpdate(str_sql) < 1) {
                throw new Exception("No hubo filas afectadas");
            }
            */
            
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
    
    public int insert(Connection p_conn) throws SQLException {
        
        int ret = -1;
        Statement stmt = null;
        ResultSet rs = null;

        String str_sql =
            "    INSERT INTO recordatorio" +
            "    (" +
            "    fecha, " +
            "    descripcion, " +
            "    recordar_km, " +
            "    km, " +
            "    recordar_fecha, " +
            "    id_recordatorio, " +
            "    titulo, " +
            "    id_usuario, " +
            "    id_vehiculo, " +
            "    recordatoriocol)" +
            "    VALUES" +
            "    (" +
            "    " + (_fecha != null ? "'" + _fecha + "'" : "null") + "," +
            "    " + (_descripcion != null ? "'" + _descripcion + "'" : "null") + "," +
            "    " + (_recordar_km != null ? "'" + _recordar_km + "'" : "null") + "," +
            "    " + (_km != null ? "'" + _km + "'" : "null") + "," +
            "    " + (_recordar_fecha != null ? "'" + _recordar_fecha + "'" : "null") + "," +
            "    " + (_id_recordatorio != null ? "'" + _id_recordatorio + "'" : "null") + "," +
            "    " + (_titulo != null ? "'" + _titulo + "'" : "null") + "," +
            "    " + (_id_usuario != null ? "'" + _id_usuario + "'" : "null") + "," +
            "    " + (_id_vehiculo != null ? "'" + _id_vehiculo + "'" : "null") + "," +
            "    " + (_recordatoriocol != null ? "'" + _recordatoriocol + "'" : "null") +
            "    )";
        
        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);

        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }

    public int delete(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    DELETE FROM recordatorio" +
            "    WHERE" +
            "    id_recordatorio = Integer.toString(this._id_recordatorio)" AND
            "    id_usuario = Integer.toString(this._id_usuario)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
}

DEBUG [main] (SQLiteORM.java:139) - table: red_social
DEBUG [main] (SQLiteORM.java:150) - columns:
/**
 * 
 */
package bd;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.AbstractMap;
import java.util.ArrayList;

/**
 * @author petete-ntbk
 *
 */
public class Red_social {
private Integer _id;
private String _red_social;

    private final static String _str_sql = 
        "    SELECT" +
        "    re.id_red_social AS id," +
        "    re.red_social AS red_social" +
        "    FROM red_social re";

    public Red_social() {
        _id = null;
        _red_social = null;

    }
    /**
     * @return the _id
     */
    public Integer get_id() {
        return _id;
    }
    /**
     * @return the _red_social
     */
    public String get_red_social() {
        return _red_social;
    }
    /**
     * @param _id the _id to set
     */
    public void set_id(Integer _id) {
        this._id = _id;
    }
    /**
     * @param _red_social the _red_social to set
     */
    public void set_red_social(String _red_social) {
        this._red_social = _red_social;
    }

    public static Red_social fromRS(ResultSet p_rs) throws SQLException {
        Red_social ret = new Red_social();

        ret.set_id(p_rs.getInt("id"));
        ret.set_red_social(p_rs.getString("red_social"));

        return ret;
    }

    public static Red_social getByParameter(Connection p_conn, String p_key, String p_value) throws SQLException {
        Red_social ret = null;
        
        String str_sql = _str_sql +
            "  WHERE re." + p_key + " = " + p_value +
            "  LIMIT 0, 1";
        
        //System.out.println(str_sql);
        
        // assume that conn is an already created JDBC connection (see previous examples)
        Statement stmt = null;
        ResultSet rs = null;
        
        try {
            stmt = p_conn.createStatement();
            //System.out.println("stmt = p_conn.createStatement() ok");
            rs = stmt.executeQuery(str_sql);
            //System.out.println("rs = stmt.executeQuery(str_sql) ok");

            // Now do something with the ResultSet ....
            
            if (rs.next()) {
                //System.out.println("rs.next() ok");
                ret = fromRS(rs);
                //System.out.println("fromRS(rs) ok");
            }
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        
        
        return ret;        
    }

    public static Red_social getById(Connection p_conn, String p_id) throws Exception {
        return getByParameter(p_conn, "id_red_social", p_id);
    }
    
    public static ArrayList<Red_social> seek(Connection p_conn, ArrayList<AbstractMap.SimpleEntry<String, String>> p_parameters, String p_order, String p_direction, int p_offset, int p_limit) throws Exception {
        Statement stmt = null;
        ResultSet rs = null;
        String str_sql;
        ArrayList<Red_social> ret;
        
        str_sql = "";
        
        try {
            ArrayList<String> array_clauses = new ArrayList<String>();
            
            ret = new ArrayList<Red_social>();
            
            str_sql = _str_sql;
            
            for (AbstractMap.SimpleEntry<String, String> p : p_parameters) {
                if (p.getKey().equals("id_red_social")) {
                    array_clauses.add("re.id_red_social = " + p.getValue());
                }
                else {
                    throw new Exception("Parametro no soportado: " + p.getKey());
                }
            }
                                
            boolean bFirstTime = false;
            
            for(String clause : array_clauses) {
                if (!bFirstTime) {
                     bFirstTime = true;
                     str_sql += " WHERE ";
                }
                else {
                     str_sql += " AND ";
                }
                str_sql += clause;
            }
            
            if (p_order != null && p_direction != null) {
                str_sql += " ORDER BY " + p_order + " " + p_direction;
            }
            
            if (p_offset != -1 && p_limit != -1) {
                str_sql += "  LIMIT " +  Integer.toString(p_offset) + ", " + Integer.toString(p_limit);
            }
            
            //echo "<br>" . str_sql . "<br>";
        
            stmt = p_conn.createStatement();
            
            rs = stmt.executeQuery(str_sql);
            
            while (rs.next()) {
                ret.add(fromRS(rs));
            }
            /*
            if (ret.size() == 0) {
                ret = null;
            }
            */
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        catch (Exception ex) {
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        

        return ret;
    }

    public int update(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    UPDATE red_social" +
            "    SET" +
            "    red_social = " + (_red_social != null ? "'" + _red_social + "'" : "null") +
            "    WHERE" +
            "    id_red_social = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
            /*
            if (stmt.executeUpdate(str_sql) < 1) {
                throw new Exception("No hubo filas afectadas");
            }
            */
            
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
    
    public int insert(Connection p_conn) throws SQLException {
        
        int ret = -1;
        Statement stmt = null;
        ResultSet rs = null;

        String str_sql =
            "    INSERT INTO red_social" +
            "    (" +
            "    id_red_social, " +
            "    red_social)" +
            "    VALUES" +
            "    (" +
            "    " + (_id_red_social != null ? "'" + _id_red_social + "'" : "null") + "," +
            "    " + (_red_social != null ? "'" + _red_social + "'" : "null") +
            "    )";
        
        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);

        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }

    public int delete(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    DELETE FROM red_social" +
            "    WHERE" +
            "    id_red_social = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
}

DEBUG [main] (SQLiteORM.java:139) - table: region
DEBUG [main] (SQLiteORM.java:150) - columns:
/**
 * 
 */
package bd;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.AbstractMap;
import java.util.ArrayList;

/**
 * @author petete-ntbk
 *
 */
public class Region {
private String _region;
private Integer _id;
private Integer _id_pais;

    private final static String _str_sql = 
        "    SELECT" +
        "    re.region AS region," +
        "    re.id_region AS id," +
        "    re.id_pais AS id_pais" +
        "    FROM region re";

    public Region() {
        _region = null;
        _id = null;
        _id_pais = null;

    }
    /**
     * @return the _region
     */
    public String get_region() {
        return _region;
    }
    /**
     * @return the _id
     */
    public Integer get_id() {
        return _id;
    }
    /**
     * @return the _id_pais
     */
    public Integer get_id_pais() {
        return _id_pais;
    }
    /**
     * @param _region the _region to set
     */
    public void set_region(String _region) {
        this._region = _region;
    }
    /**
     * @param _id the _id to set
     */
    public void set_id(Integer _id) {
        this._id = _id;
    }
    /**
     * @param _id_pais the _id_pais to set
     */
    public void set_id_pais(Integer _id_pais) {
        this._id_pais = _id_pais;
    }

    public static Region fromRS(ResultSet p_rs) throws SQLException {
        Region ret = new Region();

        ret.set_region(p_rs.getString("region"));
        ret.set_id(p_rs.getInt("id"));
        ret.set_id_pais(p_rs.getInt("id_pais"));

        return ret;
    }

    public static Region getByParameter(Connection p_conn, String p_key, String p_value) throws SQLException {
        Region ret = null;
        
        String str_sql = _str_sql +
            "  WHERE re." + p_key + " = " + p_value +
            "  LIMIT 0, 1";
        
        //System.out.println(str_sql);
        
        // assume that conn is an already created JDBC connection (see previous examples)
        Statement stmt = null;
        ResultSet rs = null;
        
        try {
            stmt = p_conn.createStatement();
            //System.out.println("stmt = p_conn.createStatement() ok");
            rs = stmt.executeQuery(str_sql);
            //System.out.println("rs = stmt.executeQuery(str_sql) ok");

            // Now do something with the ResultSet ....
            
            if (rs.next()) {
                //System.out.println("rs.next() ok");
                ret = fromRS(rs);
                //System.out.println("fromRS(rs) ok");
            }
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        
        
        return ret;        
    }

    public static Region getById(Connection p_conn, String p_id) throws Exception {
        return getByParameter(p_conn, "id_region", p_id);
    }
    
    public static ArrayList<Region> seek(Connection p_conn, ArrayList<AbstractMap.SimpleEntry<String, String>> p_parameters, String p_order, String p_direction, int p_offset, int p_limit) throws Exception {
        Statement stmt = null;
        ResultSet rs = null;
        String str_sql;
        ArrayList<Region> ret;
        
        str_sql = "";
        
        try {
            ArrayList<String> array_clauses = new ArrayList<String>();
            
            ret = new ArrayList<Region>();
            
            str_sql = _str_sql;
            
            for (AbstractMap.SimpleEntry<String, String> p : p_parameters) {
                if (p.getKey().equals("id_region")) {
                    array_clauses.add("re.id_region = " + p.getValue());
                }
                else if (p.getKey().equals("id_pais")) {
                    array_clauses.add("re.id_pais = " + p.getValue());
                }
                else {
                    throw new Exception("Parametro no soportado: " + p.getKey());
                }
            }
                                
            boolean bFirstTime = false;
            
            for(String clause : array_clauses) {
                if (!bFirstTime) {
                     bFirstTime = true;
                     str_sql += " WHERE ";
                }
                else {
                     str_sql += " AND ";
                }
                str_sql += clause;
            }
            
            if (p_order != null && p_direction != null) {
                str_sql += " ORDER BY " + p_order + " " + p_direction;
            }
            
            if (p_offset != -1 && p_limit != -1) {
                str_sql += "  LIMIT " +  Integer.toString(p_offset) + ", " + Integer.toString(p_limit);
            }
            
            //echo "<br>" . str_sql . "<br>";
        
            stmt = p_conn.createStatement();
            
            rs = stmt.executeQuery(str_sql);
            
            while (rs.next()) {
                ret.add(fromRS(rs));
            }
            /*
            if (ret.size() == 0) {
                ret = null;
            }
            */
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        catch (Exception ex) {
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        

        return ret;
    }

    public int update(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    UPDATE region" +
            "    SET" +
            "    region = " + (_region != null ? "'" + _region + "'" : "null") +
            "    WHERE" +
            "    id_region = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
            /*
            if (stmt.executeUpdate(str_sql) < 1) {
                throw new Exception("No hubo filas afectadas");
            }
            */
            
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
    
    public int insert(Connection p_conn) throws SQLException {
        
        int ret = -1;
        Statement stmt = null;
        ResultSet rs = null;

        String str_sql =
            "    INSERT INTO region" +
            "    (" +
            "    region, " +
            "    id_region, " +
            "    id_pais)" +
            "    VALUES" +
            "    (" +
            "    " + (_region != null ? "'" + _region + "'" : "null") + "," +
            "    " + (_id_region != null ? "'" + _id_region + "'" : "null") + "," +
            "    " + (_id_pais != null ? "'" + _id_pais + "'" : "null") +
            "    )";
        
        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);

        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }

    public int delete(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    DELETE FROM region" +
            "    WHERE" +
            "    id_region = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
}

DEBUG [main] (SQLiteORM.java:139) - table: rendimiento
DEBUG [main] (SQLiteORM.java:150) - columns:
/**
 * 
 */
package bd;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.AbstractMap;
import java.util.ArrayList;

/**
 * @author petete-ntbk
 *
 */
public class Rendimiento {
private String _fecha;
private String _estanque_lleno;
private Integer _id_rendimiento;
private Integer _costo;
private Integer _km;
private Integer _litros;
private Integer _id_usuario;
private Integer _id_vehiculo;
private Integer _latitud;
private Integer _longitud;

    private final static String _str_sql = 
        "    SELECT" +
        "    re.fecha AS fecha," +
        "    re.estanque_lleno AS estanque_lleno," +
        "    re.id_rendimiento AS id_rendimiento," +
        "    re.costo AS costo," +
        "    re.km AS km," +
        "    re.litros AS litros," +
        "    re.id_usuario AS id_usuario," +
        "    re.id_vehiculo AS id_vehiculo," +
        "    re.latitud AS latitud," +
        "    re.longitud AS longitud" +
        "    FROM rendimiento re";

    public Rendimiento() {
        _fecha = null;
        _estanque_lleno = null;
        _id_rendimiento = null;
        _costo = null;
        _km = null;
        _litros = null;
        _id_usuario = null;
        _id_vehiculo = null;
        _latitud = null;
        _longitud = null;

    }
    /**
     * @return the _fecha
     */
    public String get_fecha() {
        return _fecha;
    }
    /**
     * @return the _estanque_lleno
     */
    public String get_estanque_lleno() {
        return _estanque_lleno;
    }
    /**
     * @return the _id_rendimiento
     */
    public Integer get_id_rendimiento() {
        return _id_rendimiento;
    }
    /**
     * @return the _costo
     */
    public Integer get_costo() {
        return _costo;
    }
    /**
     * @return the _km
     */
    public Integer get_km() {
        return _km;
    }
    /**
     * @return the _litros
     */
    public Integer get_litros() {
        return _litros;
    }
    /**
     * @return the _id_usuario
     */
    public Integer get_id_usuario() {
        return _id_usuario;
    }
    /**
     * @return the _id_vehiculo
     */
    public Integer get_id_vehiculo() {
        return _id_vehiculo;
    }
    /**
     * @return the _latitud
     */
    public Integer get_latitud() {
        return _latitud;
    }
    /**
     * @return the _longitud
     */
    public Integer get_longitud() {
        return _longitud;
    }
    /**
     * @param _fecha the _fecha to set
     */
    public void set_fecha(String _fecha) {
        this._fecha = _fecha;
    }
    /**
     * @param _estanque_lleno the _estanque_lleno to set
     */
    public void set_estanque_lleno(String _estanque_lleno) {
        this._estanque_lleno = _estanque_lleno;
    }
    /**
     * @param _id_rendimiento the _id_rendimiento to set
     */
    public void set_id_rendimiento(Integer _id_rendimiento) {
        this._id_rendimiento = _id_rendimiento;
    }
    /**
     * @param _costo the _costo to set
     */
    public void set_costo(Integer _costo) {
        this._costo = _costo;
    }
    /**
     * @param _km the _km to set
     */
    public void set_km(Integer _km) {
        this._km = _km;
    }
    /**
     * @param _litros the _litros to set
     */
    public void set_litros(Integer _litros) {
        this._litros = _litros;
    }
    /**
     * @param _id_usuario the _id_usuario to set
     */
    public void set_id_usuario(Integer _id_usuario) {
        this._id_usuario = _id_usuario;
    }
    /**
     * @param _id_vehiculo the _id_vehiculo to set
     */
    public void set_id_vehiculo(Integer _id_vehiculo) {
        this._id_vehiculo = _id_vehiculo;
    }
    /**
     * @param _latitud the _latitud to set
     */
    public void set_latitud(Integer _latitud) {
        this._latitud = _latitud;
    }
    /**
     * @param _longitud the _longitud to set
     */
    public void set_longitud(Integer _longitud) {
        this._longitud = _longitud;
    }

    public static Rendimiento fromRS(ResultSet p_rs) throws SQLException {
        Rendimiento ret = new Rendimiento();

        ret.set_fecha(p_rs.getString("fecha"));
        ret.set_estanque_lleno(p_rs.getString("estanque_lleno"));
        ret.set_id_rendimiento(p_rs.getInt("id_rendimiento"));
        ret.set_costo(p_rs.getInt("costo"));
        ret.set_km(p_rs.getInt("km"));
        ret.set_litros(p_rs.getInt("litros"));
        ret.set_id_usuario(p_rs.getInt("id_usuario"));
        ret.set_id_vehiculo(p_rs.getInt("id_vehiculo"));
        ret.set_latitud(p_rs.getInt("latitud"));
        ret.set_longitud(p_rs.getInt("longitud"));

        return ret;
    }

    public static Rendimiento getByParameter(Connection p_conn, String p_key, String p_value) throws SQLException {
        Rendimiento ret = null;
        
        String str_sql = _str_sql +
            "  WHERE re." + p_key + " = " + p_value +
            "  LIMIT 0, 1";
        
        //System.out.println(str_sql);
        
        // assume that conn is an already created JDBC connection (see previous examples)
        Statement stmt = null;
        ResultSet rs = null;
        
        try {
            stmt = p_conn.createStatement();
            //System.out.println("stmt = p_conn.createStatement() ok");
            rs = stmt.executeQuery(str_sql);
            //System.out.println("rs = stmt.executeQuery(str_sql) ok");

            // Now do something with the ResultSet ....
            
            if (rs.next()) {
                //System.out.println("rs.next() ok");
                ret = fromRS(rs);
                //System.out.println("fromRS(rs) ok");
            }
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        
        
        return ret;        
    }

    
    public static ArrayList<Rendimiento> seek(Connection p_conn, ArrayList<AbstractMap.SimpleEntry<String, String>> p_parameters, String p_order, String p_direction, int p_offset, int p_limit) throws Exception {
        Statement stmt = null;
        ResultSet rs = null;
        String str_sql;
        ArrayList<Rendimiento> ret;
        
        str_sql = "";
        
        try {
            ArrayList<String> array_clauses = new ArrayList<String>();
            
            ret = new ArrayList<Rendimiento>();
            
            str_sql = _str_sql;
            
            for (AbstractMap.SimpleEntry<String, String> p : p_parameters) {
                if (p.getKey().equals("id_usuario")) {
                    array_clauses.add("re.id_usuario = " + p.getValue());
                }
                else if (p.getKey().equals("id_rendimiento")) {
                    array_clauses.add("re.id_rendimiento = " + p.getValue());
                }
                else if (p.getKey().equals("id_usuario")) {
                    array_clauses.add("re.id_usuario = " + p.getValue());
                }
                else if (p.getKey().equals("id_vehiculo")) {
                    array_clauses.add("re.id_vehiculo = " + p.getValue());
                }
                else {
                    throw new Exception("Parametro no soportado: " + p.getKey());
                }
            }
                                
            boolean bFirstTime = false;
            
            for(String clause : array_clauses) {
                if (!bFirstTime) {
                     bFirstTime = true;
                     str_sql += " WHERE ";
                }
                else {
                     str_sql += " AND ";
                }
                str_sql += clause;
            }
            
            if (p_order != null && p_direction != null) {
                str_sql += " ORDER BY " + p_order + " " + p_direction;
            }
            
            if (p_offset != -1 && p_limit != -1) {
                str_sql += "  LIMIT " +  Integer.toString(p_offset) + ", " + Integer.toString(p_limit);
            }
            
            //echo "<br>" . str_sql . "<br>";
        
            stmt = p_conn.createStatement();
            
            rs = stmt.executeQuery(str_sql);
            
            while (rs.next()) {
                ret.add(fromRS(rs));
            }
            /*
            if (ret.size() == 0) {
                ret = null;
            }
            */
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        catch (Exception ex) {
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        

        return ret;
    }

    public int update(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    UPDATE rendimiento" +
            "    SET" +
            "    fecha = " + (_fecha != null ? "'" + _fecha + "'" : "null") + "," +
            "    estanque_lleno = " + (_estanque_lleno != null ? "'" + _estanque_lleno + "'" : "null") + "," +
            "    costo = " + (_costo != null ? _costo : "null") + "," +
            "    km = " + (_km != null ? _km : "null") + "," +
            "    litros = " + (_litros != null ? _litros : "null") + "," +
            "    latitud = " + (_latitud != null ? _latitud : "null") + "," +
            "    longitud = " + (_longitud != null ? _longitud : "null") +
            "    WHERE" +
            "    id_usuario = Integer.toString(this._id_usuario)" AND
            "    id_rendimiento = Integer.toString(this._id_rendimiento)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
            /*
            if (stmt.executeUpdate(str_sql) < 1) {
                throw new Exception("No hubo filas afectadas");
            }
            */
            
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
    
    public int insert(Connection p_conn) throws SQLException {
        
        int ret = -1;
        Statement stmt = null;
        ResultSet rs = null;

        String str_sql =
            "    INSERT INTO rendimiento" +
            "    (" +
            "    fecha, " +
            "    estanque_lleno, " +
            "    id_rendimiento, " +
            "    costo, " +
            "    km, " +
            "    litros, " +
            "    id_usuario, " +
            "    id_vehiculo, " +
            "    latitud, " +
            "    longitud)" +
            "    VALUES" +
            "    (" +
            "    " + (_fecha != null ? "'" + _fecha + "'" : "null") + "," +
            "    " + (_estanque_lleno != null ? "'" + _estanque_lleno + "'" : "null") + "," +
            "    " + (_id_rendimiento != null ? "'" + _id_rendimiento + "'" : "null") + "," +
            "    " + (_costo != null ? "'" + _costo + "'" : "null") + "," +
            "    " + (_km != null ? "'" + _km + "'" : "null") + "," +
            "    " + (_litros != null ? "'" + _litros + "'" : "null") + "," +
            "    " + (_id_usuario != null ? "'" + _id_usuario + "'" : "null") + "," +
            "    " + (_id_vehiculo != null ? "'" + _id_vehiculo + "'" : "null") + "," +
            "    " + (_latitud != null ? "'" + _latitud + "'" : "null") + "," +
            "    " + (_longitud != null ? "'" + _longitud + "'" : "null") +
            "    )";
        
        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);

        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }

    public int delete(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    DELETE FROM rendimiento" +
            "    WHERE" +
            "    id_usuario = Integer.toString(this._id_usuario)" AND
            "    id_rendimiento = Integer.toString(this._id_rendimiento)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
}

DEBUG [main] (SQLiteORM.java:139) - table: reparacion
DEBUG [main] (SQLiteORM.java:150) - columns:
/**
 * 
 */
package bd;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.AbstractMap;
import java.util.ArrayList;

/**
 * @author petete-ntbk
 *
 */
public class Reparacion {
private String _descripcion;
private Integer _costo;
private String _titulo;
private String _fecha_modificacion;
private Integer _id_usuario;
private Integer _id_vehiculo;
private Integer _id_reparacion;

    private final static String _str_sql = 
        "    SELECT" +
        "    re.descripcion AS descripcion," +
        "    re.costo AS costo," +
        "    re.titulo AS titulo," +
        "    re.fecha_modificacion AS fecha_modificacion," +
        "    re.id_usuario AS id_usuario," +
        "    re.id_vehiculo AS id_vehiculo," +
        "    re.id_reparacion AS id_reparacion" +
        "    FROM reparacion re";

    public Reparacion() {
        _descripcion = null;
        _costo = null;
        _titulo = null;
        _fecha_modificacion = null;
        _id_usuario = null;
        _id_vehiculo = null;
        _id_reparacion = null;

    }
    /**
     * @return the _descripcion
     */
    public String get_descripcion() {
        return _descripcion;
    }
    /**
     * @return the _costo
     */
    public Integer get_costo() {
        return _costo;
    }
    /**
     * @return the _titulo
     */
    public String get_titulo() {
        return _titulo;
    }
    /**
     * @return the _fecha_modificacion
     */
    public String get_fecha_modificacion() {
        return _fecha_modificacion;
    }
    /**
     * @return the _id_usuario
     */
    public Integer get_id_usuario() {
        return _id_usuario;
    }
    /**
     * @return the _id_vehiculo
     */
    public Integer get_id_vehiculo() {
        return _id_vehiculo;
    }
    /**
     * @return the _id_reparacion
     */
    public Integer get_id_reparacion() {
        return _id_reparacion;
    }
    /**
     * @param _descripcion the _descripcion to set
     */
    public void set_descripcion(String _descripcion) {
        this._descripcion = _descripcion;
    }
    /**
     * @param _costo the _costo to set
     */
    public void set_costo(Integer _costo) {
        this._costo = _costo;
    }
    /**
     * @param _titulo the _titulo to set
     */
    public void set_titulo(String _titulo) {
        this._titulo = _titulo;
    }
    /**
     * @param _fecha_modificacion the _fecha_modificacion to set
     */
    public void set_fecha_modificacion(String _fecha_modificacion) {
        this._fecha_modificacion = _fecha_modificacion;
    }
    /**
     * @param _id_usuario the _id_usuario to set
     */
    public void set_id_usuario(Integer _id_usuario) {
        this._id_usuario = _id_usuario;
    }
    /**
     * @param _id_vehiculo the _id_vehiculo to set
     */
    public void set_id_vehiculo(Integer _id_vehiculo) {
        this._id_vehiculo = _id_vehiculo;
    }
    /**
     * @param _id_reparacion the _id_reparacion to set
     */
    public void set_id_reparacion(Integer _id_reparacion) {
        this._id_reparacion = _id_reparacion;
    }

    public static Reparacion fromRS(ResultSet p_rs) throws SQLException {
        Reparacion ret = new Reparacion();

        ret.set_descripcion(p_rs.getString("descripcion"));
        ret.set_costo(p_rs.getInt("costo"));
        ret.set_titulo(p_rs.getString("titulo"));
        ret.set_fecha_modificacion(p_rs.getString("fecha_modificacion"));
        ret.set_id_usuario(p_rs.getInt("id_usuario"));
        ret.set_id_vehiculo(p_rs.getInt("id_vehiculo"));
        ret.set_id_reparacion(p_rs.getInt("id_reparacion"));

        return ret;
    }

    public static Reparacion getByParameter(Connection p_conn, String p_key, String p_value) throws SQLException {
        Reparacion ret = null;
        
        String str_sql = _str_sql +
            "  WHERE re." + p_key + " = " + p_value +
            "  LIMIT 0, 1";
        
        //System.out.println(str_sql);
        
        // assume that conn is an already created JDBC connection (see previous examples)
        Statement stmt = null;
        ResultSet rs = null;
        
        try {
            stmt = p_conn.createStatement();
            //System.out.println("stmt = p_conn.createStatement() ok");
            rs = stmt.executeQuery(str_sql);
            //System.out.println("rs = stmt.executeQuery(str_sql) ok");

            // Now do something with the ResultSet ....
            
            if (rs.next()) {
                //System.out.println("rs.next() ok");
                ret = fromRS(rs);
                //System.out.println("fromRS(rs) ok");
            }
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        
        
        return ret;        
    }

    
    public static ArrayList<Reparacion> seek(Connection p_conn, ArrayList<AbstractMap.SimpleEntry<String, String>> p_parameters, String p_order, String p_direction, int p_offset, int p_limit) throws Exception {
        Statement stmt = null;
        ResultSet rs = null;
        String str_sql;
        ArrayList<Reparacion> ret;
        
        str_sql = "";
        
        try {
            ArrayList<String> array_clauses = new ArrayList<String>();
            
            ret = new ArrayList<Reparacion>();
            
            str_sql = _str_sql;
            
            for (AbstractMap.SimpleEntry<String, String> p : p_parameters) {
                if (p.getKey().equals("id_usuario")) {
                    array_clauses.add("re.id_usuario = " + p.getValue());
                }
                else if (p.getKey().equals("id_reparacion")) {
                    array_clauses.add("re.id_reparacion = " + p.getValue());
                }
                else if (p.getKey().equals("id_usuario")) {
                    array_clauses.add("re.id_usuario = " + p.getValue());
                }
                else if (p.getKey().equals("id_vehiculo")) {
                    array_clauses.add("re.id_vehiculo = " + p.getValue());
                }
                else if (p.getKey().equals("mas reciente")) {
                    array_clauses.add("re.fecha_modificacion > STR_TO_DATE('" + p.getValue() + "', '%d-%m-%Y %H:%i:%s')");
                }
                else {
                    throw new Exception("Parametro no soportado: " + p.getKey());
                }
            }
                                
            boolean bFirstTime = false;
            
            for(String clause : array_clauses) {
                if (!bFirstTime) {
                     bFirstTime = true;
                     str_sql += " WHERE ";
                }
                else {
                     str_sql += " AND ";
                }
                str_sql += clause;
            }
            
            if (p_order != null && p_direction != null) {
                str_sql += " ORDER BY " + p_order + " " + p_direction;
            }
            
            if (p_offset != -1 && p_limit != -1) {
                str_sql += "  LIMIT " +  Integer.toString(p_offset) + ", " + Integer.toString(p_limit);
            }
            
            //echo "<br>" . str_sql . "<br>";
        
            stmt = p_conn.createStatement();
            
            rs = stmt.executeQuery(str_sql);
            
            while (rs.next()) {
                ret.add(fromRS(rs));
            }
            /*
            if (ret.size() == 0) {
                ret = null;
            }
            */
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        catch (Exception ex) {
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        

        return ret;
    }

    public int update(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    UPDATE reparacion" +
            "    SET" +
            "    descripcion = " + (_descripcion != null ? "'" + _descripcion + "'" : "null") + "," +
            "    costo = " + (_costo != null ? _costo : "null") + "," +
            "    titulo = " + (_titulo != null ? "'" + _titulo + "'" : "null") + "," +
            "    fecha_modificacion = " + (_fecha_modificacion != null ? "'" + _fecha_modificacion + "'" : "null") +
            "    WHERE" +
            "    id_usuario = Integer.toString(this._id_usuario)" AND
            "    id_reparacion = Integer.toString(this._id_reparacion)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
            /*
            if (stmt.executeUpdate(str_sql) < 1) {
                throw new Exception("No hubo filas afectadas");
            }
            */
            
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
    
    public int insert(Connection p_conn) throws SQLException {
        
        int ret = -1;
        Statement stmt = null;
        ResultSet rs = null;

        String str_sql =
            "    INSERT INTO reparacion" +
            "    (" +
            "    descripcion, " +
            "    costo, " +
            "    titulo, " +
            "    id_usuario, " +
            "    id_vehiculo, " +
            "    id_reparacion)" +
            "    VALUES" +
            "    (" +
            "    " + (_descripcion != null ? "'" + _descripcion + "'" : "null") + "," +
            "    " + (_costo != null ? "'" + _costo + "'" : "null") + "," +
            "    " + (_titulo != null ? "'" + _titulo + "'" : "null") + "," +
            "    " + (_id_usuario != null ? "'" + _id_usuario + "'" : "null") + "," +
            "    " + (_id_vehiculo != null ? "'" + _id_vehiculo + "'" : "null") + "," +
            "    " + (_id_reparacion != null ? "'" + _id_reparacion + "'" : "null") +
            "    )";
        
        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);

        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }

    public int delete(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    DELETE FROM reparacion" +
            "    WHERE" +
            "    id_usuario = Integer.toString(this._id_usuario)" AND
            "    id_reparacion = Integer.toString(this._id_reparacion)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
}

DEBUG [main] (SQLiteORM.java:139) - table: tipo_transmision
DEBUG [main] (SQLiteORM.java:150) - columns:
/**
 * 
 */
package bd;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.AbstractMap;
import java.util.ArrayList;

/**
 * @author petete-ntbk
 *
 */
public class Tipo_transmision {
private String _descripcion;
private String _fecha_modificacion;
private Integer _id;

    private final static String _str_sql = 
        "    SELECT" +
        "    ti.descripcion AS descripcion," +
        "    ti.fecha_modificacion AS fecha_modificacion," +
        "    ti.id_tipo_transmision AS id" +
        "    FROM tipo_transmision ti";

    public Tipo_transmision() {
        _descripcion = null;
        _fecha_modificacion = null;
        _id = null;

    }
    /**
     * @return the _descripcion
     */
    public String get_descripcion() {
        return _descripcion;
    }
    /**
     * @return the _fecha_modificacion
     */
    public String get_fecha_modificacion() {
        return _fecha_modificacion;
    }
    /**
     * @return the _id
     */
    public Integer get_id() {
        return _id;
    }
    /**
     * @param _descripcion the _descripcion to set
     */
    public void set_descripcion(String _descripcion) {
        this._descripcion = _descripcion;
    }
    /**
     * @param _fecha_modificacion the _fecha_modificacion to set
     */
    public void set_fecha_modificacion(String _fecha_modificacion) {
        this._fecha_modificacion = _fecha_modificacion;
    }
    /**
     * @param _id the _id to set
     */
    public void set_id(Integer _id) {
        this._id = _id;
    }

    public static Tipo_transmision fromRS(ResultSet p_rs) throws SQLException {
        Tipo_transmision ret = new Tipo_transmision();

        ret.set_descripcion(p_rs.getString("descripcion"));
        ret.set_fecha_modificacion(p_rs.getString("fecha_modificacion"));
        ret.set_id(p_rs.getInt("id"));

        return ret;
    }

    public static Tipo_transmision getByParameter(Connection p_conn, String p_key, String p_value) throws SQLException {
        Tipo_transmision ret = null;
        
        String str_sql = _str_sql +
            "  WHERE ti." + p_key + " = " + p_value +
            "  LIMIT 0, 1";
        
        //System.out.println(str_sql);
        
        // assume that conn is an already created JDBC connection (see previous examples)
        Statement stmt = null;
        ResultSet rs = null;
        
        try {
            stmt = p_conn.createStatement();
            //System.out.println("stmt = p_conn.createStatement() ok");
            rs = stmt.executeQuery(str_sql);
            //System.out.println("rs = stmt.executeQuery(str_sql) ok");

            // Now do something with the ResultSet ....
            
            if (rs.next()) {
                //System.out.println("rs.next() ok");
                ret = fromRS(rs);
                //System.out.println("fromRS(rs) ok");
            }
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        
        
        return ret;        
    }

    public static Tipo_transmision getById(Connection p_conn, String p_id) throws Exception {
        return getByParameter(p_conn, "id_tipo_transmision", p_id);
    }
    
    public static ArrayList<Tipo_transmision> seek(Connection p_conn, ArrayList<AbstractMap.SimpleEntry<String, String>> p_parameters, String p_order, String p_direction, int p_offset, int p_limit) throws Exception {
        Statement stmt = null;
        ResultSet rs = null;
        String str_sql;
        ArrayList<Tipo_transmision> ret;
        
        str_sql = "";
        
        try {
            ArrayList<String> array_clauses = new ArrayList<String>();
            
            ret = new ArrayList<Tipo_transmision>();
            
            str_sql = _str_sql;
            
            for (AbstractMap.SimpleEntry<String, String> p : p_parameters) {
                if (p.getKey().equals("id_tipo_transmision")) {
                    array_clauses.add("ti.id_tipo_transmision = " + p.getValue());
                }
                else if (p.getKey().equals("mas reciente")) {
                    array_clauses.add("ti.fecha_modificacion > STR_TO_DATE('" + p.getValue() + "', '%d-%m-%Y %H:%i:%s')");
                }
                else {
                    throw new Exception("Parametro no soportado: " + p.getKey());
                }
            }
                                
            boolean bFirstTime = false;
            
            for(String clause : array_clauses) {
                if (!bFirstTime) {
                     bFirstTime = true;
                     str_sql += " WHERE ";
                }
                else {
                     str_sql += " AND ";
                }
                str_sql += clause;
            }
            
            if (p_order != null && p_direction != null) {
                str_sql += " ORDER BY " + p_order + " " + p_direction;
            }
            
            if (p_offset != -1 && p_limit != -1) {
                str_sql += "  LIMIT " +  Integer.toString(p_offset) + ", " + Integer.toString(p_limit);
            }
            
            //echo "<br>" . str_sql . "<br>";
        
            stmt = p_conn.createStatement();
            
            rs = stmt.executeQuery(str_sql);
            
            while (rs.next()) {
                ret.add(fromRS(rs));
            }
            /*
            if (ret.size() == 0) {
                ret = null;
            }
            */
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        catch (Exception ex) {
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        

        return ret;
    }

    public int update(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    UPDATE tipo_transmision" +
            "    SET" +
            "    descripcion = " + (_descripcion != null ? "'" + _descripcion + "'" : "null") + "," +
            "    fecha_modificacion = " + (_fecha_modificacion != null ? "'" + _fecha_modificacion + "'" : "null") +
            "    WHERE" +
            "    id_tipo_transmision = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
            /*
            if (stmt.executeUpdate(str_sql) < 1) {
                throw new Exception("No hubo filas afectadas");
            }
            */
            
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
    
    public int insert(Connection p_conn) throws SQLException {
        
        int ret = -1;
        Statement stmt = null;
        ResultSet rs = null;

        String str_sql =
            "    INSERT INTO tipo_transmision" +
            "    (" +
            "    descripcion, " +
            "    id_tipo_transmision)" +
            "    VALUES" +
            "    (" +
            "    " + (_descripcion != null ? "'" + _descripcion + "'" : "null") + "," +
            "    " + (_id_tipo_transmision != null ? "'" + _id_tipo_transmision + "'" : "null") +
            "    )";
        
        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);

        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }

    public int delete(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    DELETE FROM tipo_transmision" +
            "    WHERE" +
            "    id_tipo_transmision = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
}

DEBUG [main] (SQLiteORM.java:139) - table: tipo_vehiculo
DEBUG [main] (SQLiteORM.java:150) - columns:
/**
 * 
 */
package bd;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.AbstractMap;
import java.util.ArrayList;

/**
 * @author petete-ntbk
 *
 */
public class Tipo_vehiculo {
private String _descripcion;
private Integer _id;
private String _fecha_modificacion;

    private final static String _str_sql = 
        "    SELECT" +
        "    ti.descripcion AS descripcion," +
        "    ti.id_tipo_vehiculo AS id," +
        "    ti.fecha_modificacion AS fecha_modificacion" +
        "    FROM tipo_vehiculo ti";

    public Tipo_vehiculo() {
        _descripcion = null;
        _id = null;
        _fecha_modificacion = null;

    }
    /**
     * @return the _descripcion
     */
    public String get_descripcion() {
        return _descripcion;
    }
    /**
     * @return the _id
     */
    public Integer get_id() {
        return _id;
    }
    /**
     * @return the _fecha_modificacion
     */
    public String get_fecha_modificacion() {
        return _fecha_modificacion;
    }
    /**
     * @param _descripcion the _descripcion to set
     */
    public void set_descripcion(String _descripcion) {
        this._descripcion = _descripcion;
    }
    /**
     * @param _id the _id to set
     */
    public void set_id(Integer _id) {
        this._id = _id;
    }
    /**
     * @param _fecha_modificacion the _fecha_modificacion to set
     */
    public void set_fecha_modificacion(String _fecha_modificacion) {
        this._fecha_modificacion = _fecha_modificacion;
    }

    public static Tipo_vehiculo fromRS(ResultSet p_rs) throws SQLException {
        Tipo_vehiculo ret = new Tipo_vehiculo();

        ret.set_descripcion(p_rs.getString("descripcion"));
        ret.set_id(p_rs.getInt("id"));
        ret.set_fecha_modificacion(p_rs.getString("fecha_modificacion"));

        return ret;
    }

    public static Tipo_vehiculo getByParameter(Connection p_conn, String p_key, String p_value) throws SQLException {
        Tipo_vehiculo ret = null;
        
        String str_sql = _str_sql +
            "  WHERE ti." + p_key + " = " + p_value +
            "  LIMIT 0, 1";
        
        //System.out.println(str_sql);
        
        // assume that conn is an already created JDBC connection (see previous examples)
        Statement stmt = null;
        ResultSet rs = null;
        
        try {
            stmt = p_conn.createStatement();
            //System.out.println("stmt = p_conn.createStatement() ok");
            rs = stmt.executeQuery(str_sql);
            //System.out.println("rs = stmt.executeQuery(str_sql) ok");

            // Now do something with the ResultSet ....
            
            if (rs.next()) {
                //System.out.println("rs.next() ok");
                ret = fromRS(rs);
                //System.out.println("fromRS(rs) ok");
            }
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        
        
        return ret;        
    }

    public static Tipo_vehiculo getById(Connection p_conn, String p_id) throws Exception {
        return getByParameter(p_conn, "id_tipo_vehiculo", p_id);
    }
    
    public static ArrayList<Tipo_vehiculo> seek(Connection p_conn, ArrayList<AbstractMap.SimpleEntry<String, String>> p_parameters, String p_order, String p_direction, int p_offset, int p_limit) throws Exception {
        Statement stmt = null;
        ResultSet rs = null;
        String str_sql;
        ArrayList<Tipo_vehiculo> ret;
        
        str_sql = "";
        
        try {
            ArrayList<String> array_clauses = new ArrayList<String>();
            
            ret = new ArrayList<Tipo_vehiculo>();
            
            str_sql = _str_sql;
            
            for (AbstractMap.SimpleEntry<String, String> p : p_parameters) {
                if (p.getKey().equals("id_tipo_vehiculo")) {
                    array_clauses.add("ti.id_tipo_vehiculo = " + p.getValue());
                }
                else if (p.getKey().equals("mas reciente")) {
                    array_clauses.add("ti.fecha_modificacion > STR_TO_DATE('" + p.getValue() + "', '%d-%m-%Y %H:%i:%s')");
                }
                else {
                    throw new Exception("Parametro no soportado: " + p.getKey());
                }
            }
                                
            boolean bFirstTime = false;
            
            for(String clause : array_clauses) {
                if (!bFirstTime) {
                     bFirstTime = true;
                     str_sql += " WHERE ";
                }
                else {
                     str_sql += " AND ";
                }
                str_sql += clause;
            }
            
            if (p_order != null && p_direction != null) {
                str_sql += " ORDER BY " + p_order + " " + p_direction;
            }
            
            if (p_offset != -1 && p_limit != -1) {
                str_sql += "  LIMIT " +  Integer.toString(p_offset) + ", " + Integer.toString(p_limit);
            }
            
            //echo "<br>" . str_sql . "<br>";
        
            stmt = p_conn.createStatement();
            
            rs = stmt.executeQuery(str_sql);
            
            while (rs.next()) {
                ret.add(fromRS(rs));
            }
            /*
            if (ret.size() == 0) {
                ret = null;
            }
            */
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        catch (Exception ex) {
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        

        return ret;
    }

    public int update(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    UPDATE tipo_vehiculo" +
            "    SET" +
            "    descripcion = " + (_descripcion != null ? "'" + _descripcion + "'" : "null") + "," +
            "    fecha_modificacion = " + (_fecha_modificacion != null ? "'" + _fecha_modificacion + "'" : "null") +
            "    WHERE" +
            "    id_tipo_vehiculo = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
            /*
            if (stmt.executeUpdate(str_sql) < 1) {
                throw new Exception("No hubo filas afectadas");
            }
            */
            
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
    
    public int insert(Connection p_conn) throws SQLException {
        
        int ret = -1;
        Statement stmt = null;
        ResultSet rs = null;

        String str_sql =
            "    INSERT INTO tipo_vehiculo" +
            "    (" +
            "    descripcion, " +
            "    id_tipo_vehiculo)" +
            "    VALUES" +
            "    (" +
            "    " + (_descripcion != null ? "'" + _descripcion + "'" : "null") + "," +
            "    " + (_id_tipo_vehiculo != null ? "'" + _id_tipo_vehiculo + "'" : "null") +
            "    )";
        
        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);

        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }

    public int delete(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    DELETE FROM tipo_vehiculo" +
            "    WHERE" +
            "    id_tipo_vehiculo = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
}

DEBUG [main] (SQLiteORM.java:139) - table: traccion
DEBUG [main] (SQLiteORM.java:150) - columns:
/**
 * 
 */
package bd;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.AbstractMap;
import java.util.ArrayList;

/**
 * @author petete-ntbk
 *
 */
public class Traccion {
private String _descripcion;
private Integer _id;
private String _fecha_modificacion;

    private final static String _str_sql = 
        "    SELECT" +
        "    tr.descripcion AS descripcion," +
        "    tr.id_traccion AS id," +
        "    tr.fecha_modificacion AS fecha_modificacion" +
        "    FROM traccion tr";

    public Traccion() {
        _descripcion = null;
        _id = null;
        _fecha_modificacion = null;

    }
    /**
     * @return the _descripcion
     */
    public String get_descripcion() {
        return _descripcion;
    }
    /**
     * @return the _id
     */
    public Integer get_id() {
        return _id;
    }
    /**
     * @return the _fecha_modificacion
     */
    public String get_fecha_modificacion() {
        return _fecha_modificacion;
    }
    /**
     * @param _descripcion the _descripcion to set
     */
    public void set_descripcion(String _descripcion) {
        this._descripcion = _descripcion;
    }
    /**
     * @param _id the _id to set
     */
    public void set_id(Integer _id) {
        this._id = _id;
    }
    /**
     * @param _fecha_modificacion the _fecha_modificacion to set
     */
    public void set_fecha_modificacion(String _fecha_modificacion) {
        this._fecha_modificacion = _fecha_modificacion;
    }

    public static Traccion fromRS(ResultSet p_rs) throws SQLException {
        Traccion ret = new Traccion();

        ret.set_descripcion(p_rs.getString("descripcion"));
        ret.set_id(p_rs.getInt("id"));
        ret.set_fecha_modificacion(p_rs.getString("fecha_modificacion"));

        return ret;
    }

    public static Traccion getByParameter(Connection p_conn, String p_key, String p_value) throws SQLException {
        Traccion ret = null;
        
        String str_sql = _str_sql +
            "  WHERE tr." + p_key + " = " + p_value +
            "  LIMIT 0, 1";
        
        //System.out.println(str_sql);
        
        // assume that conn is an already created JDBC connection (see previous examples)
        Statement stmt = null;
        ResultSet rs = null;
        
        try {
            stmt = p_conn.createStatement();
            //System.out.println("stmt = p_conn.createStatement() ok");
            rs = stmt.executeQuery(str_sql);
            //System.out.println("rs = stmt.executeQuery(str_sql) ok");

            // Now do something with the ResultSet ....
            
            if (rs.next()) {
                //System.out.println("rs.next() ok");
                ret = fromRS(rs);
                //System.out.println("fromRS(rs) ok");
            }
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        
        
        return ret;        
    }

    public static Traccion getById(Connection p_conn, String p_id) throws Exception {
        return getByParameter(p_conn, "id_traccion", p_id);
    }
    
    public static ArrayList<Traccion> seek(Connection p_conn, ArrayList<AbstractMap.SimpleEntry<String, String>> p_parameters, String p_order, String p_direction, int p_offset, int p_limit) throws Exception {
        Statement stmt = null;
        ResultSet rs = null;
        String str_sql;
        ArrayList<Traccion> ret;
        
        str_sql = "";
        
        try {
            ArrayList<String> array_clauses = new ArrayList<String>();
            
            ret = new ArrayList<Traccion>();
            
            str_sql = _str_sql;
            
            for (AbstractMap.SimpleEntry<String, String> p : p_parameters) {
                if (p.getKey().equals("id_traccion")) {
                    array_clauses.add("tr.id_traccion = " + p.getValue());
                }
                else if (p.getKey().equals("mas reciente")) {
                    array_clauses.add("tr.fecha_modificacion > STR_TO_DATE('" + p.getValue() + "', '%d-%m-%Y %H:%i:%s')");
                }
                else {
                    throw new Exception("Parametro no soportado: " + p.getKey());
                }
            }
                                
            boolean bFirstTime = false;
            
            for(String clause : array_clauses) {
                if (!bFirstTime) {
                     bFirstTime = true;
                     str_sql += " WHERE ";
                }
                else {
                     str_sql += " AND ";
                }
                str_sql += clause;
            }
            
            if (p_order != null && p_direction != null) {
                str_sql += " ORDER BY " + p_order + " " + p_direction;
            }
            
            if (p_offset != -1 && p_limit != -1) {
                str_sql += "  LIMIT " +  Integer.toString(p_offset) + ", " + Integer.toString(p_limit);
            }
            
            //echo "<br>" . str_sql . "<br>";
        
            stmt = p_conn.createStatement();
            
            rs = stmt.executeQuery(str_sql);
            
            while (rs.next()) {
                ret.add(fromRS(rs));
            }
            /*
            if (ret.size() == 0) {
                ret = null;
            }
            */
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        catch (Exception ex) {
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        

        return ret;
    }

    public int update(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    UPDATE traccion" +
            "    SET" +
            "    descripcion = " + (_descripcion != null ? "'" + _descripcion + "'" : "null") + "," +
            "    fecha_modificacion = " + (_fecha_modificacion != null ? "'" + _fecha_modificacion + "'" : "null") +
            "    WHERE" +
            "    id_traccion = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
            /*
            if (stmt.executeUpdate(str_sql) < 1) {
                throw new Exception("No hubo filas afectadas");
            }
            */
            
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
    
    public int insert(Connection p_conn) throws SQLException {
        
        int ret = -1;
        Statement stmt = null;
        ResultSet rs = null;

        String str_sql =
            "    INSERT INTO traccion" +
            "    (" +
            "    descripcion, " +
            "    id_traccion)" +
            "    VALUES" +
            "    (" +
            "    " + (_descripcion != null ? "'" + _descripcion + "'" : "null") + "," +
            "    " + (_id_traccion != null ? "'" + _id_traccion + "'" : "null") +
            "    )";
        
        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);

        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }

    public int delete(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    DELETE FROM traccion" +
            "    WHERE" +
            "    id_traccion = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
}

DEBUG [main] (SQLiteORM.java:139) - table: usuario
DEBUG [main] (SQLiteORM.java:150) - columns:
/**
 * 
 */
package bd;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.AbstractMap;
import java.util.ArrayList;

/**
 * @author petete-ntbk
 *
 */
public class Usuario {
private String _fecha_vencimiento_licencia;
private String _hombre;
private String _borrado;
private String _telefono;
private String _fecha_modifiacion;
private String _fecha_nacimiento;
private String _nombre;
private Integer _id;
private Integer _id_comuna;
private String _correo;

    private final static String _str_sql = 
        "    SELECT" +
        "    us.fecha_vencimiento_licencia AS fecha_vencimiento_licencia," +
        "    us.hombre AS hombre," +
        "    us.borrado AS borrado," +
        "    us.telefono AS telefono," +
        "    us.fecha_modifiacion AS fecha_modifiacion," +
        "    us.fecha_nacimiento AS fecha_nacimiento," +
        "    us.nombre AS nombre," +
        "    us.id_usuario AS id," +
        "    us.id_comuna AS id_comuna," +
        "    us.correo AS correo" +
        "    FROM usuario us";

    public Usuario() {
        _fecha_vencimiento_licencia = null;
        _hombre = null;
        _borrado = null;
        _telefono = null;
        _fecha_modifiacion = null;
        _fecha_nacimiento = null;
        _nombre = null;
        _id = null;
        _id_comuna = null;
        _correo = null;

    }
    /**
     * @return the _fecha_vencimiento_licencia
     */
    public String get_fecha_vencimiento_licencia() {
        return _fecha_vencimiento_licencia;
    }
    /**
     * @return the _hombre
     */
    public String get_hombre() {
        return _hombre;
    }
    /**
     * @return the _borrado
     */
    public String get_borrado() {
        return _borrado;
    }
    /**
     * @return the _telefono
     */
    public String get_telefono() {
        return _telefono;
    }
    /**
     * @return the _fecha_modifiacion
     */
    public String get_fecha_modifiacion() {
        return _fecha_modifiacion;
    }
    /**
     * @return the _fecha_nacimiento
     */
    public String get_fecha_nacimiento() {
        return _fecha_nacimiento;
    }
    /**
     * @return the _nombre
     */
    public String get_nombre() {
        return _nombre;
    }
    /**
     * @return the _id
     */
    public Integer get_id() {
        return _id;
    }
    /**
     * @return the _id_comuna
     */
    public Integer get_id_comuna() {
        return _id_comuna;
    }
    /**
     * @return the _correo
     */
    public String get_correo() {
        return _correo;
    }
    /**
     * @param _fecha_vencimiento_licencia the _fecha_vencimiento_licencia to set
     */
    public void set_fecha_vencimiento_licencia(String _fecha_vencimiento_licencia) {
        this._fecha_vencimiento_licencia = _fecha_vencimiento_licencia;
    }
    /**
     * @param _hombre the _hombre to set
     */
    public void set_hombre(String _hombre) {
        this._hombre = _hombre;
    }
    /**
     * @param _borrado the _borrado to set
     */
    public void set_borrado(String _borrado) {
        this._borrado = _borrado;
    }
    /**
     * @param _telefono the _telefono to set
     */
    public void set_telefono(String _telefono) {
        this._telefono = _telefono;
    }
    /**
     * @param _fecha_modifiacion the _fecha_modifiacion to set
     */
    public void set_fecha_modifiacion(String _fecha_modifiacion) {
        this._fecha_modifiacion = _fecha_modifiacion;
    }
    /**
     * @param _fecha_nacimiento the _fecha_nacimiento to set
     */
    public void set_fecha_nacimiento(String _fecha_nacimiento) {
        this._fecha_nacimiento = _fecha_nacimiento;
    }
    /**
     * @param _nombre the _nombre to set
     */
    public void set_nombre(String _nombre) {
        this._nombre = _nombre;
    }
    /**
     * @param _id the _id to set
     */
    public void set_id(Integer _id) {
        this._id = _id;
    }
    /**
     * @param _id_comuna the _id_comuna to set
     */
    public void set_id_comuna(Integer _id_comuna) {
        this._id_comuna = _id_comuna;
    }
    /**
     * @param _correo the _correo to set
     */
    public void set_correo(String _correo) {
        this._correo = _correo;
    }

    public static Usuario fromRS(ResultSet p_rs) throws SQLException {
        Usuario ret = new Usuario();

        ret.set_fecha_vencimiento_licencia(p_rs.getString("fecha_vencimiento_licencia"));
        ret.set_hombre(p_rs.getString("hombre"));
        ret.set_borrado(p_rs.getString("borrado"));
        ret.set_telefono(p_rs.getString("telefono"));
        ret.set_fecha_modifiacion(p_rs.getString("fecha_modifiacion"));
        ret.set_fecha_nacimiento(p_rs.getString("fecha_nacimiento"));
        ret.set_nombre(p_rs.getString("nombre"));
        ret.set_id(p_rs.getInt("id"));
        ret.set_id_comuna(p_rs.getInt("id_comuna"));
        ret.set_correo(p_rs.getString("correo"));

        return ret;
    }

    public static Usuario getByParameter(Connection p_conn, String p_key, String p_value) throws SQLException {
        Usuario ret = null;
        
        String str_sql = _str_sql +
            "  WHERE us." + p_key + " = " + p_value +
            "  LIMIT 0, 1";
        
        //System.out.println(str_sql);
        
        // assume that conn is an already created JDBC connection (see previous examples)
        Statement stmt = null;
        ResultSet rs = null;
        
        try {
            stmt = p_conn.createStatement();
            //System.out.println("stmt = p_conn.createStatement() ok");
            rs = stmt.executeQuery(str_sql);
            //System.out.println("rs = stmt.executeQuery(str_sql) ok");

            // Now do something with the ResultSet ....
            
            if (rs.next()) {
                //System.out.println("rs.next() ok");
                ret = fromRS(rs);
                //System.out.println("fromRS(rs) ok");
            }
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        
        
        return ret;        
    }

    public static Usuario getById(Connection p_conn, String p_id) throws Exception {
        return getByParameter(p_conn, "id_usuario", p_id);
    }
    
    public static ArrayList<Usuario> seek(Connection p_conn, ArrayList<AbstractMap.SimpleEntry<String, String>> p_parameters, String p_order, String p_direction, int p_offset, int p_limit) throws Exception {
        Statement stmt = null;
        ResultSet rs = null;
        String str_sql;
        ArrayList<Usuario> ret;
        
        str_sql = "";
        
        try {
            ArrayList<String> array_clauses = new ArrayList<String>();
            
            ret = new ArrayList<Usuario>();
            
            str_sql = _str_sql;
            
            for (AbstractMap.SimpleEntry<String, String> p : p_parameters) {
                if (p.getKey().equals("id_usuario")) {
                    array_clauses.add("us.id_usuario = " + p.getValue());
                }
                else if (p.getKey().equals("id_comuna")) {
                    array_clauses.add("us.id_comuna = " + p.getValue());
                }
                else {
                    throw new Exception("Parametro no soportado: " + p.getKey());
                }
            }
                                
            boolean bFirstTime = false;
            
            for(String clause : array_clauses) {
                if (!bFirstTime) {
                     bFirstTime = true;
                     str_sql += " WHERE ";
                }
                else {
                     str_sql += " AND ";
                }
                str_sql += clause;
            }
            
            if (p_order != null && p_direction != null) {
                str_sql += " ORDER BY " + p_order + " " + p_direction;
            }
            
            if (p_offset != -1 && p_limit != -1) {
                str_sql += "  LIMIT " +  Integer.toString(p_offset) + ", " + Integer.toString(p_limit);
            }
            
            //echo "<br>" . str_sql . "<br>";
        
            stmt = p_conn.createStatement();
            
            rs = stmt.executeQuery(str_sql);
            
            while (rs.next()) {
                ret.add(fromRS(rs));
            }
            /*
            if (ret.size() == 0) {
                ret = null;
            }
            */
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        catch (Exception ex) {
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        

        return ret;
    }

    public int update(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    UPDATE usuario" +
            "    SET" +
            "    fecha_vencimiento_licencia = " + (_fecha_vencimiento_licencia != null ? "'" + _fecha_vencimiento_licencia + "'" : "null") + "," +
            "    hombre = " + (_hombre != null ? "'" + _hombre + "'" : "null") + "," +
            "    borrado = " + (_borrado != null ? "'" + _borrado + "'" : "null") + "," +
            "    telefono = " + (_telefono != null ? "'" + _telefono + "'" : "null") + "," +
            "    fecha_modifiacion = " + (_fecha_modifiacion != null ? "'" + _fecha_modifiacion + "'" : "null") + "," +
            "    fecha_nacimiento = " + (_fecha_nacimiento != null ? "'" + _fecha_nacimiento + "'" : "null") + "," +
            "    nombre = " + (_nombre != null ? "'" + _nombre + "'" : "null") + "," +
            "    correo = " + (_correo != null ? "'" + _correo + "'" : "null") +
            "    WHERE" +
            "    id_usuario = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
            /*
            if (stmt.executeUpdate(str_sql) < 1) {
                throw new Exception("No hubo filas afectadas");
            }
            */
            
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
    
    public int insert(Connection p_conn) throws SQLException {
        
        int ret = -1;
        Statement stmt = null;
        ResultSet rs = null;

        String str_sql =
            "    INSERT INTO usuario" +
            "    (" +
            "    fecha_vencimiento_licencia, " +
            "    hombre, " +
            "    telefono, " +
            "    fecha_nacimiento, " +
            "    nombre, " +
            "    id_usuario, " +
            "    id_comuna, " +
            "    correo)" +
            "    VALUES" +
            "    (" +
            "    " + (_fecha_vencimiento_licencia != null ? "'" + _fecha_vencimiento_licencia + "'" : "null") + "," +
            "    " + (_hombre != null ? "'" + _hombre + "'" : "null") + "," +
            "    " + (_telefono != null ? "'" + _telefono + "'" : "null") + "," +
            "    " + (_fecha_nacimiento != null ? "'" + _fecha_nacimiento + "'" : "null") + "," +
            "    " + (_nombre != null ? "'" + _nombre + "'" : "null") + "," +
            "    " + (_id_usuario != null ? "'" + _id_usuario + "'" : "null") + "," +
            "    " + (_id_comuna != null ? "'" + _id_comuna + "'" : "null") + "," +
            "    " + (_correo != null ? "'" + _correo + "'" : "null") +
            "    )";
        
        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);

        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }

    public int delete(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    DELETE FROM usuario" +
            "    WHERE" +
            "    id_usuario = Integer.toString(this._id)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
}

DEBUG [main] (SQLiteORM.java:139) - table: vehiculo
DEBUG [main] (SQLiteORM.java:150) - columns:
/**
 * 
 */
package bd;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.AbstractMap;
import java.util.ArrayList;

/**
 * @author petete-ntbk
 *
 */
public class Vehiculo {
private Integer _anio;
private String _aire_acondicionado;
private String _alias;
private String _borrado;
private Integer _id_traccion;
private Integer _km;
private String _alza_vidrios;
private String _fecha_modificacion;
private Integer _id_usuario;
private Integer _id_vehiculo;
private String _patente;
private Integer _id_modelo;
private Integer _id_combustible;
private Integer _id_tipo_transmision;

    private final static String _str_sql = 
        "    SELECT" +
        "    ve.anio AS anio," +
        "    ve.aire_acondicionado AS aire_acondicionado," +
        "    ve.alias AS alias," +
        "    ve.borrado AS borrado," +
        "    ve.id_traccion AS id_traccion," +
        "    ve.km AS km," +
        "    ve.alza_vidrios AS alza_vidrios," +
        "    ve.fecha_modificacion AS fecha_modificacion," +
        "    ve.id_usuario AS id_usuario," +
        "    ve.id_vehiculo AS id_vehiculo," +
        "    ve.patente AS patente," +
        "    ve.id_modelo AS id_modelo," +
        "    ve.id_combustible AS id_combustible," +
        "    ve.id_tipo_transmision AS id_tipo_transmision" +
        "    FROM vehiculo ve";

    public Vehiculo() {
        _anio = null;
        _aire_acondicionado = null;
        _alias = null;
        _borrado = null;
        _id_traccion = null;
        _km = null;
        _alza_vidrios = null;
        _fecha_modificacion = null;
        _id_usuario = null;
        _id_vehiculo = null;
        _patente = null;
        _id_modelo = null;
        _id_combustible = null;
        _id_tipo_transmision = null;

    }
    /**
     * @return the _anio
     */
    public Integer get_anio() {
        return _anio;
    }
    /**
     * @return the _aire_acondicionado
     */
    public String get_aire_acondicionado() {
        return _aire_acondicionado;
    }
    /**
     * @return the _alias
     */
    public String get_alias() {
        return _alias;
    }
    /**
     * @return the _borrado
     */
    public String get_borrado() {
        return _borrado;
    }
    /**
     * @return the _id_traccion
     */
    public Integer get_id_traccion() {
        return _id_traccion;
    }
    /**
     * @return the _km
     */
    public Integer get_km() {
        return _km;
    }
    /**
     * @return the _alza_vidrios
     */
    public String get_alza_vidrios() {
        return _alza_vidrios;
    }
    /**
     * @return the _fecha_modificacion
     */
    public String get_fecha_modificacion() {
        return _fecha_modificacion;
    }
    /**
     * @return the _id_usuario
     */
    public Integer get_id_usuario() {
        return _id_usuario;
    }
    /**
     * @return the _id_vehiculo
     */
    public Integer get_id_vehiculo() {
        return _id_vehiculo;
    }
    /**
     * @return the _patente
     */
    public String get_patente() {
        return _patente;
    }
    /**
     * @return the _id_modelo
     */
    public Integer get_id_modelo() {
        return _id_modelo;
    }
    /**
     * @return the _id_combustible
     */
    public Integer get_id_combustible() {
        return _id_combustible;
    }
    /**
     * @return the _id_tipo_transmision
     */
    public Integer get_id_tipo_transmision() {
        return _id_tipo_transmision;
    }
    /**
     * @param _anio the _anio to set
     */
    public void set_anio(Integer _anio) {
        this._anio = _anio;
    }
    /**
     * @param _aire_acondicionado the _aire_acondicionado to set
     */
    public void set_aire_acondicionado(String _aire_acondicionado) {
        this._aire_acondicionado = _aire_acondicionado;
    }
    /**
     * @param _alias the _alias to set
     */
    public void set_alias(String _alias) {
        this._alias = _alias;
    }
    /**
     * @param _borrado the _borrado to set
     */
    public void set_borrado(String _borrado) {
        this._borrado = _borrado;
    }
    /**
     * @param _id_traccion the _id_traccion to set
     */
    public void set_id_traccion(Integer _id_traccion) {
        this._id_traccion = _id_traccion;
    }
    /**
     * @param _km the _km to set
     */
    public void set_km(Integer _km) {
        this._km = _km;
    }
    /**
     * @param _alza_vidrios the _alza_vidrios to set
     */
    public void set_alza_vidrios(String _alza_vidrios) {
        this._alza_vidrios = _alza_vidrios;
    }
    /**
     * @param _fecha_modificacion the _fecha_modificacion to set
     */
    public void set_fecha_modificacion(String _fecha_modificacion) {
        this._fecha_modificacion = _fecha_modificacion;
    }
    /**
     * @param _id_usuario the _id_usuario to set
     */
    public void set_id_usuario(Integer _id_usuario) {
        this._id_usuario = _id_usuario;
    }
    /**
     * @param _id_vehiculo the _id_vehiculo to set
     */
    public void set_id_vehiculo(Integer _id_vehiculo) {
        this._id_vehiculo = _id_vehiculo;
    }
    /**
     * @param _patente the _patente to set
     */
    public void set_patente(String _patente) {
        this._patente = _patente;
    }
    /**
     * @param _id_modelo the _id_modelo to set
     */
    public void set_id_modelo(Integer _id_modelo) {
        this._id_modelo = _id_modelo;
    }
    /**
     * @param _id_combustible the _id_combustible to set
     */
    public void set_id_combustible(Integer _id_combustible) {
        this._id_combustible = _id_combustible;
    }
    /**
     * @param _id_tipo_transmision the _id_tipo_transmision to set
     */
    public void set_id_tipo_transmision(Integer _id_tipo_transmision) {
        this._id_tipo_transmision = _id_tipo_transmision;
    }

    public static Vehiculo fromRS(ResultSet p_rs) throws SQLException {
        Vehiculo ret = new Vehiculo();

        ret.set_anio(p_rs.getInt("anio"));
        ret.set_aire_acondicionado(p_rs.getString("aire_acondicionado"));
        ret.set_alias(p_rs.getString("alias"));
        ret.set_borrado(p_rs.getString("borrado"));
        ret.set_id_traccion(p_rs.getInt("id_traccion"));
        ret.set_km(p_rs.getInt("km"));
        ret.set_alza_vidrios(p_rs.getString("alza_vidrios"));
        ret.set_fecha_modificacion(p_rs.getString("fecha_modificacion"));
        ret.set_id_usuario(p_rs.getInt("id_usuario"));
        ret.set_id_vehiculo(p_rs.getInt("id_vehiculo"));
        ret.set_patente(p_rs.getString("patente"));
        ret.set_id_modelo(p_rs.getInt("id_modelo"));
        ret.set_id_combustible(p_rs.getInt("id_combustible"));
        ret.set_id_tipo_transmision(p_rs.getInt("id_tipo_transmision"));

        return ret;
    }

    public static Vehiculo getByParameter(Connection p_conn, String p_key, String p_value) throws SQLException {
        Vehiculo ret = null;
        
        String str_sql = _str_sql +
            "  WHERE ve." + p_key + " = " + p_value +
            "  LIMIT 0, 1";
        
        //System.out.println(str_sql);
        
        // assume that conn is an already created JDBC connection (see previous examples)
        Statement stmt = null;
        ResultSet rs = null;
        
        try {
            stmt = p_conn.createStatement();
            //System.out.println("stmt = p_conn.createStatement() ok");
            rs = stmt.executeQuery(str_sql);
            //System.out.println("rs = stmt.executeQuery(str_sql) ok");

            // Now do something with the ResultSet ....
            
            if (rs.next()) {
                //System.out.println("rs.next() ok");
                ret = fromRS(rs);
                //System.out.println("fromRS(rs) ok");
            }
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        
        
        return ret;        
    }

    
    public static ArrayList<Vehiculo> seek(Connection p_conn, ArrayList<AbstractMap.SimpleEntry<String, String>> p_parameters, String p_order, String p_direction, int p_offset, int p_limit) throws Exception {
        Statement stmt = null;
        ResultSet rs = null;
        String str_sql;
        ArrayList<Vehiculo> ret;
        
        str_sql = "";
        
        try {
            ArrayList<String> array_clauses = new ArrayList<String>();
            
            ret = new ArrayList<Vehiculo>();
            
            str_sql = _str_sql;
            
            for (AbstractMap.SimpleEntry<String, String> p : p_parameters) {
                if (p.getKey().equals("id_usuario")) {
                    array_clauses.add("ve.id_usuario = " + p.getValue());
                }
                else if (p.getKey().equals("id_vehiculo")) {
                    array_clauses.add("ve.id_vehiculo = " + p.getValue());
                }
                else if (p.getKey().equals("id_usuario")) {
                    array_clauses.add("ve.id_usuario = " + p.getValue());
                }
                else if (p.getKey().equals("id_modelo")) {
                    array_clauses.add("ve.id_modelo = " + p.getValue());
                }
                else if (p.getKey().equals("id_traccion")) {
                    array_clauses.add("ve.id_traccion = " + p.getValue());
                }
                else if (p.getKey().equals("id_tipo_transmision")) {
                    array_clauses.add("ve.id_tipo_transmision = " + p.getValue());
                }
                else if (p.getKey().equals("id_combustible")) {
                    array_clauses.add("ve.id_combustible = " + p.getValue());
                }
                else if (p.getKey().equals("mas reciente")) {
                    array_clauses.add("ve.fecha_modificacion > STR_TO_DATE('" + p.getValue() + "', '%d-%m-%Y %H:%i:%s')");
                }
                else {
                    throw new Exception("Parametro no soportado: " + p.getKey());
                }
            }
                                
            boolean bFirstTime = false;
            
            for(String clause : array_clauses) {
                if (!bFirstTime) {
                     bFirstTime = true;
                     str_sql += " WHERE ";
                }
                else {
                     str_sql += " AND ";
                }
                str_sql += clause;
            }
            
            if (p_order != null && p_direction != null) {
                str_sql += " ORDER BY " + p_order + " " + p_direction;
            }
            
            if (p_offset != -1 && p_limit != -1) {
                str_sql += "  LIMIT " +  Integer.toString(p_offset) + ", " + Integer.toString(p_limit);
            }
            
            //echo "<br>" . str_sql . "<br>";
        
            stmt = p_conn.createStatement();
            
            rs = stmt.executeQuery(str_sql);
            
            while (rs.next()) {
                ret.add(fromRS(rs));
            }
            /*
            if (ret.size() == 0) {
                ret = null;
            }
            */
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        catch (Exception ex) {
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }        

        return ret;
    }

    public int update(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    UPDATE vehiculo" +
            "    SET" +
            "    anio = " + (_anio != null ? _anio : "null") + "," +
            "    aire_acondicionado = " + (_aire_acondicionado != null ? "'" + _aire_acondicionado + "'" : "null") + "," +
            "    alias = " + (_alias != null ? "'" + _alias + "'" : "null") + "," +
            "    borrado = " + (_borrado != null ? "'" + _borrado + "'" : "null") + "," +
            "    km = " + (_km != null ? _km : "null") + "," +
            "    alza_vidrios = " + (_alza_vidrios != null ? "'" + _alza_vidrios + "'" : "null") + "," +
            "    fecha_modificacion = " + (_fecha_modificacion != null ? "'" + _fecha_modificacion + "'" : "null") + "," +
            "    patente = " + (_patente != null ? "'" + _patente + "'" : "null") +
            "    WHERE" +
            "    id_usuario = Integer.toString(this._id_usuario)" AND
            "    id_vehiculo = Integer.toString(this._id_vehiculo)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
            /*
            if (stmt.executeUpdate(str_sql) < 1) {
                throw new Exception("No hubo filas afectadas");
            }
            */
            
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
    
    public int insert(Connection p_conn) throws SQLException {
        
        int ret = -1;
        Statement stmt = null;
        ResultSet rs = null;

        String str_sql =
            "    INSERT INTO vehiculo" +
            "    (" +
            "    anio, " +
            "    aire_acondicionado, " +
            "    alias, " +
            "    id_traccion, " +
            "    km, " +
            "    alza_vidrios, " +
            "    id_usuario, " +
            "    id_vehiculo, " +
            "    patente, " +
            "    id_modelo, " +
            "    id_combustible, " +
            "    id_tipo_transmision)" +
            "    VALUES" +
            "    (" +
            "    " + (_anio != null ? "'" + _anio + "'" : "null") + "," +
            "    " + (_aire_acondicionado != null ? "'" + _aire_acondicionado + "'" : "null") + "," +
            "    " + (_alias != null ? "'" + _alias + "'" : "null") + "," +
            "    " + (_id_traccion != null ? "'" + _id_traccion + "'" : "null") + "," +
            "    " + (_km != null ? "'" + _km + "'" : "null") + "," +
            "    " + (_alza_vidrios != null ? "'" + _alza_vidrios + "'" : "null") + "," +
            "    " + (_id_usuario != null ? "'" + _id_usuario + "'" : "null") + "," +
            "    " + (_id_vehiculo != null ? "'" + _id_vehiculo + "'" : "null") + "," +
            "    " + (_patente != null ? "'" + _patente + "'" : "null") + "," +
            "    " + (_id_modelo != null ? "'" + _id_modelo + "'" : "null") + "," +
            "    " + (_id_combustible != null ? "'" + _id_combustible + "'" : "null") + "," +
            "    " + (_id_tipo_transmision != null ? "'" + _id_tipo_transmision + "'" : "null") +
            "    )";
        
        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);

        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException sqlEx) { 
                    
                } // ignore
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }

    public int delete(Connection p_conn) throws SQLException {

        int ret = -1;
        Statement stmt = null;

        String str_sql =
            "    DELETE FROM vehiculo" +
            "    WHERE" +
            "    id_usuario = Integer.toString(this._id_usuario)" AND
            "    id_vehiculo = Integer.toString(this._id_vehiculo)";

        try {
            stmt = p_conn.createStatement();
            
            ret = stmt.executeUpdate(str_sql);
        }
        catch (SQLException ex){
            // handle any errors
            System.out.println("SQLException: " + ex.getMessage() + " sentencia: " + str_sql);
            System.out.println("SQLState: " + ex.getSQLState());
            System.out.println("VendorError: " + ex.getErrorCode());
            
            throw ex;
        }
        finally {
            // it is a good idea to release
            // resources in a finally{} block
            // in reverse-order of their creation
            // if they are no-longer needed
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException sqlEx) {
                    
                } // ignore
                stmt = null;
            }
        }
        
        return ret;
    }
}

